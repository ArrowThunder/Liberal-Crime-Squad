#include "../includes.h"
const string CONST_fight239 = "'s neck is broken!";
const string CONST_fight238 = "'s neck bones are shattered!";
const string CONST_fight237 = "'s nose is removed!";
const string CONST_fight236 = "'s nose is cut off!";
const string CONST_fight235 = "'s nose is torn off!";
const string CONST_fight234 = "'s nose is burned away!";
const string CONST_fight233 = "'s nose is blasted off!";
const string CONST_fight232 = "'s tongue is removed!";
const string CONST_fight231 = "'s tongue is cut off!";
const string CONST_fight230 = "'s tongue is torn out!";
const string CONST_fight229 = "'s tongue is burned away!";
const string CONST_fight228 = "'s tongue is blasted off!";
const string CONST_fight227 = "'s left eye is removed!";
const string CONST_fight226 = "'s left eye is poked out!";
const string CONST_fight225 = "'s left eye is torn out!";
const string CONST_fight224 = "'s left eye is burned away!";
const string CONST_fight223 = "'s left eye is blasted out!";
const string CONST_fight222 = "'s right eye is removed!";
const string CONST_fight221 = "'s right eye is poked out!";
const string CONST_fight220 = "'s right eye is torn out!";
const string CONST_fight219 = "'s right eye is burned away!";
const string CONST_fight218 = "'s right eye is blasted out!";
const string CONST_fight217 = "knocked out!";
const string CONST_fight216 = "cut out!";
const string CONST_fight215 = "gouged out!";
const string CONST_fight214 = "burned away!";
const string CONST_fight213 = "shot out!";
const string CONST_fight212 = "'s last tooth is ";
const string CONST_fight211 = "'s teeth is ";
const string CONST_fight210 = "One of ";
const string CONST_fight209 = "'s teeth are ";
const string CONST_fight208 = " of ";
const string CONST_fight207 = "All ";
const string CONST_fight206 = "'s face is removed!";
const string CONST_fight205 = "'s face is cut away!";
const string CONST_fight204 = "'s face is torn off!";
const string CONST_fight203 = "'s face is burned away!";
const string CONST_fight202 = "'s face is blasted off!";
const string CONST_fight201 = "broken!";
const string CONST_fight200 = "shot apart!";
const string CONST_fight199 = "'s last unbroken rib is ";
const string CONST_fight198 = "'s rib is ";
const string CONST_fight196 = "'s ribs are ";
const string CONST_fight193 = "'s spleen is punctured!";
const string CONST_fight192 = "'s spleen is torn!";
const string CONST_fight191 = "'s spleen is blasted!";
const string CONST_fight190 = "'s left kidney is punctured!";
const string CONST_fight189 = "'s left kidney is torn!";
const string CONST_fight188 = "'s left kidney is blasted!";
const string CONST_fight187 = "'s right kidney is punctured!";
const string CONST_fight186 = "'s right kidney is torn!";
const string CONST_fight185 = "'s right kidney is blasted!";
const string CONST_fight184 = "'s stomach is punctured!";
const string CONST_fight183 = "'s stomach is torn!";
const string CONST_fight182 = "'s stomach is blasted!";
const string CONST_fight181 = "'s liver is punctured!";
const string CONST_fight180 = "'s liver is torn!";
const string CONST_fight179 = "'s liver is blasted!";
const string CONST_fight178 = "'s heart is punctured!";
const string CONST_fight177 = "'s heart is torn!";
const string CONST_fight176 = "'s heart is blasted!";
const string CONST_fight175 = "'s left lung is punctured!";
const string CONST_fight174 = "'s left lung is torn!";
const string CONST_fight173 = "'s left lung is blasted!";
const string CONST_fight172 = "'s right lung is punctured!";
const string CONST_fight171 = "'s right lung is torn!";
const string CONST_fight170 = "'s right lung is blasted!";
const string CONST_fight169 = "'s lower spine is broken!";
const string CONST_fight168 = "'s lower spine is shattered!";
const string CONST_fight167 = "'s upper spine is broken!";
const string CONST_fight166 = "'s upper spine is shattered!";
const string CONST_fight165 = "'s body.";
const string CONST_fight164 = " drops ";
const string CONST_fight163 = "super enemy";
const string CONST_fight162 = "dangerous enemies";
const string CONST_fight161 = "super enemies";
const string CONST_fight160 = " misses completely!";
const string CONST_fight159 = " just barely missed!";
const string CONST_fight158 = " missed!";
const string CONST_fight154 = " knocks the blow aside and counters!";
const string CONST_fight153 = " to no effect.";
const string CONST_fight152 = " BLOWING IT OFF!";
const string CONST_fight151 = " CUTTING IT OFF!";
const string CONST_fight150 = " BLOWING IT IN HALF!";
const string CONST_fight149 = " BLOWING IT APART!";
const string CONST_fight148 = " CUTTING IT IN HALF!";
const string CONST_fight146 = "!";
const string CONST_fight145 = "'s corpse";
const string CONST_fight144 = " shields ";
const string CONST_fight143 = " heroically";
const string CONST_fight142 = " misguidedly";
const string CONST_fight141 = "(ATK %d, DEF %d, DAMMOD %d, DAMAGE %d, AP %d)";
const string CONST_fight140 = "the ";
const string CONST_fight139 = "The attack bounces off ";
const string CONST_fight138 = " through ";
const string CONST_fight137 = "striking";
const string CONST_fight136 = "'s ";
const string CONST_fight135 = " hits ";
const string CONST_fight134 = " stabs ";
const string CONST_fight132 = " with a ";
const string CONST_fight131 = "sneaks up on";
const string CONST_fight130 = "bites";
const string CONST_fight129 = "stabs";
const string CONST_fight128 = "breathes fire at";
const string CONST_fight127 = "fires a 120mm shell at";
const string CONST_fight126 = "gracefully strikes at";
const string CONST_fight125 = "jump kicks";
const string CONST_fight124 = "strikes at";
const string CONST_fight123 = "kicks";
const string CONST_fight122 = "grapples with";
const string CONST_fight121 = "swings at";
const string CONST_fight120 = "punches";
const string CONST_fight119 = "MISTAKENLY ";
const string CONST_fight118 = " readies another ";
const string CONST_fight117 = " reloads.";
const string CONST_fight116 = "actual";
const string CONST_fight114 = "\"A plague on both your houses...\"";
const string CONST_fight113 = " speaks these final words: ";
const string CONST_fight112 = "soils the floor.";
const string CONST_fight111 = "[makes a mess].";
const string CONST_fight110 = " gasps a last breath and ";
const string CONST_fight109 = "something about Jesus, and dies.";
const string CONST_fight108 = "something [good] about Jesus, and dies.";
const string CONST_fight107 = " sweats profusely, murmurs ";
const string CONST_fight106 = "the neck hole, then is quiet.";
const string CONST_fight105 = " sucks a last breath through ";
const string CONST_fight104 = "neck and falls to the side.";
const string CONST_fight103 = "neck and runs down the hall.";
const string CONST_fight102 = " out of the ";
const string CONST_fight101 = "[red water]";
const string CONST_fight100 = " squirts ";
const string CONST_fight099 = "moment then crumples over.";
const string CONST_fight098 = " sits headless for a ";
const string CONST_fight097 = " stands headless for a ";
const string CONST_fight096 = "is no head, and slumps over.";
const string CONST_fight095 = "is no head, and falls.";
const string CONST_fight094 = " reaches once where there ";
const string CONST_fight093 = " has been destroyed.";
const string CONST_fight091 = "'s grasp.";
const string CONST_fight090 = " slips from";
const string CONST_fight089 = "NULL BODYPART";
const string CONST_fight088 = " remains strong.";
const string CONST_fight087 = " has turned Liberal!";
const string CONST_fight086 = "'s Heart swells!";
const string CONST_fight085 = " seems less badass!";
const string CONST_fight083 = " doesn't want to fight anymore";
const string CONST_fight081 = " is turned Conservative";
const string CONST_fight080 = " can't bear to leave!";
const string CONST_fight079 = " is tainted with Wisdom!";
const string CONST_fight078 = " loses juice!";
const string CONST_fight077 = " already agrees with ";
const string CONST_fight076 = " is immune to the attack!";
const string CONST_fight074 = "rocks out at";
const string CONST_fight073 = "plays country songs at";
const string CONST_fight072 = "plays protest songs at";
const string CONST_fight071 = " at";
const string CONST_fight070 = "blows a harmonica";
const string CONST_fight069 = "strums the ";
const string CONST_fight068 = "sings to";
const string CONST_fight067 = "plays a song for";
const string CONST_fight060 = "explains ethical research to";
const string CONST_fight059 = "explains the benefits of research to";
const string CONST_fight057 = " spits up a cluster of bloody bubbles.";
const string CONST_fight056 = " [makes a mess].";
const string CONST_fight055 = " vomits up a clot of blood.";
const string CONST_fight049 = "'s gums start chattering.";
const string CONST_fight048 = "'s tooth starts chattering.";
const string CONST_fight047 = "'s teeth start chattering.";
const string CONST_fight046 = " pisses on the floor, moaning.";
const string CONST_fight045 = " [makes a mess], moaning.";
const string CONST_fight044 = " stares out with hollow sockets.";
const string CONST_fight043 = " stares into space with one empty eye.";
const string CONST_fight042 = " stares off into space.";
const string CONST_fight041 = " leans against the door.";
const string CONST_fight040 = " stumbles against a wall.";
const string CONST_fight039 = " soils the floor.";
const string CONST_fight038 = " [makes a stinky].";
const string CONST_fight035 = " times";
const string CONST_fight034 = " five times";
const string CONST_fight033 = " four times";
const string CONST_fight032 = " three times";
const string CONST_fight031 = " twice";
const string CONST_fight030 = "evasionStringsAlt.txt";
const string CONST_fight029 = "evasionStrings.txt";
const string CONST_fight028 = "body_falls_apart.txt";
const string CONST_fight027 = "double_line_death.txt";
const string CONST_fight026 = "bleeding_animal.txt";
const string CONST_fight025 = "paralyzed_tank.txt";
const string CONST_fight024 = "paralyzed_text.txt";
const string CONST_fight023 = "stunned_text.txt";
const string CONST_fight022 = "bleeding_to_death.txt";
const string CONST_fight021 = "cry_alarm.txt";
const string CONST_fight020 = "scientist_debate.txt";
const string CONST_fight019 = "police_debate.txt";
const string CONST_fight018 = "military_debate.txt";
const string CONST_fight017 = "media_debate.txt";
const string CONST_fight016 = "other_politician_debate.txt";
const string CONST_fight015 = "conservative_politician_debate.txt";
const string CONST_fight014 = "other_ceo_debate.txt";
const string CONST_fight013 = "conservative_ceo_debate.txt";
const string CONST_fight012 = "judge_debate.txt";
const string CONST_fight011 = "escape_crawling.txt";
const string CONST_fight010 = "escape_running.txt";
const string CONST_fightX01 = " cries \"Mommy!\"";
const string CONST_fightX02 = " murmurs \"What about my offspring?\"";
const string CONST_fightX03 = " murmurs \"What about my puppies?\"";
const string CONST_fightX04 = " murmurs \"What about my children?\"";
const string CONST_fightX05 = "\"Better dead than liberal...\"";

const string tag_ARMOR = "ARMOR";
const string tag_ARMOR_PRISONER = "ARMOR_PRISONER";
const string tag_ARMOR_CLOTHES = "ARMOR_CLOTHES";
const string blankString = "";
const string tag_false = "false";
const string tag_blood = "blood";
const string tag_The = "The ";
/*
Copyright (c) 2002,2003,2004 by Tarn Adams                                            //
                                                                                      //
This file is part of Liberal Crime Squad.                                             //
                                                                                    //
    Liberal Crime Squad is free software; you can redistribute it and/or modify     //
    it under the terms of the GNU General Public License as published by            //
    the Free Software Foundation; either version 2 of the License, or               //
    (at your option) any later version.                                             //
                                                                                    //
    Liberal Crime Squad is distributed in the hope that it will be useful,          //
    but WITHOUT ANY WARRANTY; without even the implied warranty of                  //
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See the                  //
    GNU General Public License for more details.                                    //
                                                                                    //
    You should have received a copy of the GNU General Public License               //
    along with Liberal Crime Squad; if not, write to the Free Software              //
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA   02111-1307   USA     //
*/
/*
        This file was created by Chris Johnson (grundee@users.sourceforge.net)
        by copying code from game.cpp.
        To see descriptions of files and functions, see the list at
        the bottom of includes.h in the top src folder.
*/
const string tag_value = "value";
const string tag_attribute = "attribute";
const string tag_skill = "skill";
#include "../creature/creature.h"
#include "../locations/locations.h"
#include "../vehicle/vehicletype.h"
#include "../vehicle/vehicle.h"
#include "../sitemode/stealth.h"
#include "../sitemode/sitedisplay.h"
#include "../items/money.h"
#include "../log/log.h"
// for gamelog
//#include "../common/translateid.h"
int getarmortype(const string &idname);
//#include "../common/commondisplay.h"
void printparty();
#include "../common/commonactions.h"
#include "../common/commonactionsCreature.h"
// for int squadsize(const squadst *);
//#include "../combat/chaseCreature.h"
Vehicle* getChaseVehicle(const DeprecatedCreature &c);
DeprecatedCreature* getChaseDriver(const DeprecatedCreature &c);
//#include "../combat/haulkidnapCreature.h"
void freehostage(DeprecatedCreature &cr,char situation);
#include "../cursesAlternative.h"
#include "../customMaps.h"
#include "../set_color_support.h"
#include "../locations/locationsPool.h"
#include "../common/creaturePool.h"
bool goodguyattack = false;
 vector<string> escape_running;
 vector<string> escape_crawling;
 vector<string> judge_debate;
 vector<string> conservative_ceo_debate;
 vector<string> other_ceo_debate;
 vector<string> conservative_politician_debate;
 vector<string> other_politician_debate;
 vector<string> media_debate;
 vector<string> military_debate;
 vector<string> police_debate;
 vector<string> scientist_debate;
 vector<string> cry_alarm;
 vector<string> bleeding_to_death;
 vector<string> stunned_text;
 vector<string> paralyzed_text;
 vector<string> paralyzed_tank;
 vector<string> bleeding_animal;
 vector<vector<string> > double_line_death;
 vector<string> body_falls_apart;
 vector<string> evasionStringsAlt;
 vector<string> evasionStrings;
 const string fighty = "fight\\";
  const int DOUBLE_LINE = 2;
  const string mostlyendings = "mostlyendings\\";
 vector<file_and_text_collection> fighty_text_file_collection = {
	 /*fight.cpp*/
	 customText(&escape_running, fighty + CONST_fight010),
	 customText(&escape_crawling, fighty + CONST_fight011),
	 customText(&judge_debate, fighty + CONST_fight012),
	 customText(&conservative_ceo_debate, fighty + CONST_fight013),
	 customText(&other_ceo_debate, fighty + CONST_fight014),
	 customText(&conservative_politician_debate, fighty + CONST_fight015),
	 customText(&other_politician_debate, fighty + CONST_fight016),
	 customText(&media_debate, fighty + CONST_fight017),
	 customText(&military_debate, fighty + CONST_fight018),
	 customText(&police_debate, fighty + CONST_fight019),
	 customText(&scientist_debate, fighty + CONST_fight020),
	 customText(&cry_alarm, fighty + CONST_fight021),
	 customText(&bleeding_to_death, fighty + CONST_fight022),
	 customText(&stunned_text, fighty + CONST_fight023),
	 customText(&paralyzed_text, fighty + CONST_fight024),
	 customText(&paralyzed_tank, fighty + CONST_fight025),
	 customText(&bleeding_animal, fighty + CONST_fight026),
	 customText(&double_line_death, fighty + CONST_fight027, DOUBLE_LINE),
	 customText(&body_falls_apart, fighty + CONST_fight028),
	 customText(&evasionStrings, mostlyendings + CONST_fight029),
	 customText(&evasionStringsAlt, mostlyendings + CONST_fight030),
 };
 extern string singleSpace;
 extern string singleDot;
 extern string commaSpace;
 vector<Item *> groundloot;

 /* generates the loot dropped by a creature when it dies */
 void makeloot(DeprecatedCreature &cr, vector<Item *> &loot)
 {
	 extern short mode;
	 cr.drop_weapons_and_clips(&loot);
	 cr.strip(&loot);
	 if (cr.money > 0 && mode == GAMEMODE_SITE)
	 {
		 loot.push_back(new Money(cr.money));
		 cr.money = 0;
	 }
 }
 void makeloot(DeprecatedCreature &cr)
 {
	 makeloot(cr, groundloot);
 }
 bool isThereGroundLoot() {
	 return len(groundloot) > 0;
 }
 void delete_and_clear_groundloot() {
	 delete_and_clear(groundloot);
 }
 // TODO convert this to Linked List?
 /* kills the specified creature from the encounter, dropping loot */
 void delenc(const short e, const char loot)
 {
	 extern short mode;
	 extern DeprecatedCreature encounter[ENCMAX];
	 //MAKE GROUND LOOT
	 if ((mode == GAMEMODE_SITE) && loot) makeloot(encounter[e]);
	 //BURY IT
	 for (int en = e; en < ENCMAX; en++)
	 {
		 if (!encounter[en].exists) break;
		 if (en < ENCMAX - 1) encounter[en] = encounter[en + 1];
	 }
	 encounter[ENCMAX - 1].exists = 0;
 }
 void delenc(DeprecatedCreature &tk) {
	 extern DeprecatedCreature encounter[ENCMAX];
	 delenc(&tk - encounter, 0);
 }
 string specialWoundPossibilityBody(
	 DeprecatedCreature &target,
	 const char breakdam,
	 const char pokedam,
	 const char damtype
 );
 string specialWoundPossibilityHead(
	 DeprecatedCreature &target,
	 const char breakdam,
	 const char heavydam,
	 const char damtype
 );
 bool incapacitatedTank(DeprecatedCreature &a, const char noncombat, char &printed) {

	 extern Log gamelog;
	 if (a.blood <= 20 || (a.blood <= 50 && (LCSrandom(2) || a.forceinc)))
	 {
		 a.forceinc = 0;
		 if (noncombat)
		 {
			 clearmessagearea();
			 set_color_easy(WHITE_ON_BLACK_BRIGHT);
			 mvaddstrAlt(16, 1, tag_The, gamelog);
			 addstrAlt(a.name, gamelog);
			 addstrAlt(singleSpace + pickrandom(paralyzed_tank));
			 gamelog.newline();
			 printed = 1;
		 }
		 return 1;
	 }
	 return 0;

 }

 bool incapacitatedAnimal(DeprecatedCreature &a, const char noncombat, char &printed) {

	 extern Log gamelog;
	 extern short lawList[LAWNUM];
	 if (a.blood <= 20 || (a.blood <= 50 && (LCSrandom(2) || a.forceinc)))
	 {
		 a.forceinc = 0;
		 if (noncombat)
		 {
			 clearmessagearea();
			 set_color_easy(WHITE_ON_BLACK_BRIGHT);
			 mvaddstrAlt(16, 1, tag_The, gamelog);
			 addstrAlt(a.name);
			 switch (LCSrandom(3))
			 {
			 case 0: if (lawList[LAW_FREESPEECH] == -2) addstrAlt(CONST_fight038, gamelog);
					 else addstrAlt(CONST_fight039, gamelog); break;
			 default:
				 addstrAlt(singleSpace + pickrandom(bleeding_animal), gamelog); break;
			 }
			 gamelog.newline();
			 printed = 1;
		 }
		 return 1;
	 }
	 return 0;

 }
 bool incapacitatedPerson(DeprecatedCreature &a, const char noncombat, char &printed) {
	 extern Log gamelog;
	 extern short mode;
	 extern short lawList[LAWNUM];
	 if (a.blood <= 20 || (a.blood <= 50 && (LCSrandom(2) || a.forceinc)))
	 {
		 a.forceinc = 0;
		 if (noncombat)
		 {
			 clearmessagearea();
			 set_color_easy(WHITE_ON_BLACK_BRIGHT);
			 mvaddstrAlt(16, 1, a.name);
			 switch (LCSrandom(54))
			 {
				 //TODO IsaacG Complete Migration of Strings
			 case 0: if (lawList[LAW_FREESPEECH] == -2) addstrAlt(CONST_fight038);
					 else addstrAlt(CONST_fight039); break;
			 case 1: if (mode != GAMEMODE_CHASECAR) addstrAlt(CONST_fight040);
					 else addstrAlt(CONST_fight041); break;
			 case 2: if (a.special[SPECIALWOUND_RIGHTEYE] && a.special[SPECIALWOUND_LEFTEYE])
				 addstrAlt(CONST_fight042);
					 else if (a.special[SPECIALWOUND_RIGHTEYE] || a.special[SPECIALWOUND_LEFTEYE])
						 addstrAlt(CONST_fight043);
					 else addstrAlt(CONST_fight044); break;
			 case 3: if (lawList[LAW_FREESPEECH] == -2) addstrAlt(CONST_fight045);
					 else addstrAlt(CONST_fight046); break;
			 case 4: if (a.special[SPECIALWOUND_TEETH] > 1) addstrAlt(CONST_fight047);
					 else if (a.special[SPECIALWOUND_TEETH] == 1) addstrAlt(CONST_fight048);
					 else addstrAlt(CONST_fight049); break;
			 case 5: if (a.age < 20 && !a.animalgloss) addstrAlt(CONST_fightX01);
					 else switch (a.type) {
					 case CREATURE_GENETIC:
						 addstrAlt(CONST_fightX02); break;
					 case CREATURE_GUARDDOG:
						 addstrAlt(CONST_fightX03); break;
					 default:
						 addstrAlt(CONST_fightX04); break;
					 } break;
			 case 6: if (lawList[LAW_FREESPEECH] == -2)addstrAlt(CONST_fight056);
					 else addstrAlt(CONST_fight055); break;
			 case 7: if (lawList[LAW_FREESPEECH] == -2)addstrAlt(CONST_fight056);
					 else addstrAlt(CONST_fight057); break;
			 default: addstrAlt(pickrandom(bleeding_to_death));
			 }
			 printed = 1;
		 }
		 return 1;
	 }
	 if (a.stunned)
	 {
		 if (noncombat)
		 {
			 a.stunned--;
			 clearmessagearea();
			 set_color_easy(WHITE_ON_BLACK_BRIGHT);
			 mvaddstrAlt(16, 1, a.name, gamelog);
			 addstrAlt(singleSpace + pickrandom(stunned_text));
			 gamelog.newline();
			 printed = 1;
		 }
		 return 1;
	 }
	 if (a.special[SPECIALWOUND_NECK] == 2 || a.special[SPECIALWOUND_UPPERSPINE] == 2)
	 {
		 if (!noncombat)
		 {
			 clearmessagearea();
			 set_color_easy(WHITE_ON_BLACK_BRIGHT);
			 mvaddstrAlt(16, 1, a.name, gamelog);
			 addstrAlt(singleSpace + pickrandom(paralyzed_text));
			 gamelog.newline();
			 printed = 1;
		 }
		 return 1;
	 }
	 return 0;
 }
 /* checks if the creature can fight and prints flavor text if they can't */
 char incapacitated(DeprecatedCreature &a, const char noncombat, char &printed)
 {
	 printed = 0;
	 switch (a.animalgloss) {
	 case ANIMALGLOSS_TANK:
		 return incapacitatedTank(a, noncombat, printed);
	 case ANIMALGLOSS_ANIMAL:
		 return incapacitatedAnimal(a, noncombat, printed);
	 default:
		 return incapacitatedPerson(a, noncombat, printed);
	 }
 }
 string getSpecialAttackString(DeprecatedCreature &a, DeprecatedCreature &t, int &resist, int &attack) {

	 char str[200];
	 strcpy(str, a.name);
	 strcat(str, singleSpace.c_str());

	 switch (a.type)
	 {
	 case CREATURE_JUDGE_CONSERVATIVE:
	 case CREATURE_JUDGE_LIBERAL:
		 strcat(str, pickrandom(judge_debate).c_str());
		 strcat(str, singleSpace.c_str());
		 strcat(str, t.name);
		 strcat(str, CONST_fight146.c_str());
		 if (t.align == 1)
			 resist = t.skill_roll(SKILL_LAW) +
			 t.attribute_roll(ATTRIBUTE_HEART);
		 else
			 resist = t.skill_roll(SKILL_LAW) +
			 t.attribute_roll(ATTRIBUTE_WISDOM);
		 attack += a.skill_roll(SKILL_LAW);
		 break;
	 case CREATURE_SCIENTIST_EMINENT:
		 switch (LCSrandom(scientist_debate.size() + 1))
		 {
		 case 0:if (a.align == ALIGN_CONSERVATIVE)strcat(str, CONST_fight059.c_str());
				else strcat(str, CONST_fight060.c_str()); break;
		 default:
			 strcat(str, pickrandom(scientist_debate).c_str()); break;
		 }
		 strcat(str, singleSpace.c_str());
		 strcat(str, t.name);
		 strcat(str, CONST_fight146.c_str());
		 if (t.align == 1)
			 resist = t.skill_roll(SKILL_SCIENCE) +
			 t.attribute_roll(ATTRIBUTE_HEART);
		 else
			 resist = t.skill_roll(SKILL_SCIENCE) +
			 t.attribute_roll(ATTRIBUTE_WISDOM);
		 attack += a.skill_roll(SKILL_SCIENCE);
		 break;
	 case CREATURE_POLITICIAN:
		 if (a.align == -1)
			 strcat(str, pickrandom(conservative_politician_debate).c_str());
		 else
			 strcat(str, pickrandom(other_politician_debate).c_str());
		 strcat(str, singleSpace.c_str());
		 strcat(str, t.name);
		 strcat(str, CONST_fight146.c_str());
		 if (t.align == 1)
			 resist = t.skill_roll(SKILL_LAW) +
			 t.attribute_roll(ATTRIBUTE_HEART);
		 else
			 resist = t.skill_roll(SKILL_LAW) +
			 t.attribute_roll(ATTRIBUTE_WISDOM);
		 attack += a.skill_roll(SKILL_LAW);
		 break;
	 case CREATURE_CORPORATE_CEO:
		 if (a.align == -1)
			 strcat(str, pickrandom(conservative_ceo_debate).c_str());
		 else
			 strcat(str, pickrandom(other_ceo_debate).c_str());
		 strcat(str, singleSpace.c_str());
		 strcat(str, t.name);
		 strcat(str, CONST_fight146.c_str());
		 if (t.align == 1)
			 resist = t.skill_roll(SKILL_BUSINESS) +
			 t.attribute_roll(ATTRIBUTE_HEART);
		 else
			 resist = t.skill_roll(SKILL_BUSINESS) +
			 t.attribute_roll(ATTRIBUTE_WISDOM);
		 attack += a.skill_roll(SKILL_BUSINESS);
		 break;
	 case CREATURE_RADIOPERSONALITY:
	 case CREATURE_NEWSANCHOR:
		 strcat(str, pickrandom(media_debate).c_str());
		 strcat(str, singleSpace.c_str());
		 strcat(str, t.name);
		 strcat(str, CONST_fight146.c_str());
		 if (t.align == 1)
			 resist = t.attribute_roll(ATTRIBUTE_HEART);
		 else
			 resist = t.attribute_roll(ATTRIBUTE_WISDOM);
		 attack += a.attribute_roll(ATTRIBUTE_CHARISMA);
		 break;
	 case CREATURE_MILITARYOFFICER:
		 strcat(str, pickrandom(military_debate).c_str());
		 strcat(str, singleSpace.c_str());
		 strcat(str, t.name);
		 strcat(str, CONST_fight146.c_str());
		 if (t.align == 1)
			 resist = t.attribute_roll(ATTRIBUTE_HEART);
		 else
			 resist = t.attribute_roll(ATTRIBUTE_WISDOM);
		 attack += a.attribute_roll(ATTRIBUTE_CHARISMA);
		 break;
	 case CREATURE_COP:
		 if (a.enemy())
		 {
			 strcat(str, pickrandom(police_debate).c_str());
			 strcat(str, singleSpace.c_str());
			 strcat(str, t.name);
			 strcat(str, CONST_fight146.c_str());
			 resist = t.attribute_roll(ATTRIBUTE_HEART);
			 attack += a.skill_roll(SKILL_PERSUASION);
			 break;
		 }
		 //No break. If the cop is a liberal it will do a musical attack instead.
	 default:
		 if (a.get_weapon().get_specific_bool(BOOL_MUSICAL_ATTACK_) || a.type == CREATURE_COP)
		 {
			 switch (LCSrandom(5))
			 {
				 //TODO IsaacG Migrate Strings
			 case 0:strcat(str, CONST_fight067.c_str()); break;
			 case 1:strcat(str, CONST_fight068.c_str()); break;
			 case 2:if (a.get_weapon().get_specific_bool(BOOL_MUSICAL_ATTACK_))
			 {
				 strcat(str, CONST_fight069.c_str());
				 strcat(str, a.get_weapon().get_name().c_str());
			 }
					else // let's use a small enough instrument for anyone to carry in their pocket
						strcat(str, CONST_fight070.c_str());
				 strcat(str, CONST_fight071.c_str()); break;
			 case 3:if (a.align == 1)strcat(str, CONST_fight072.c_str());
					else strcat(str, CONST_fight073.c_str());
					break;
			 case 4:strcat(str, CONST_fight074.c_str()); break;
			 }
			 strcat(str, singleSpace.c_str());
			 strcat(str, t.name);
			 strcat(str, CONST_fight146.c_str());
			 attack = a.skill_roll(SKILL_MUSIC);
			 if (t.align == 1)
				 resist = t.attribute_roll(ATTRIBUTE_HEART);
			 else resist = t.attribute_roll(ATTRIBUTE_WISDOM);
			 if (resist > 0)
				 a.train(SKILL_MUSIC, LCSrandom(resist) + 1);
			 else a.train(SKILL_MUSIC, 1);
		 }
		 break;
	 }
	 return str;
 }
 void specialattack(DeprecatedCreature &a, DeprecatedCreature &t)
 {
	 extern short mode;
	 extern Log gamelog;
	 extern Deprecatedsquadst *activesquad;
	 extern short lawList[LAWNUM];
	 extern DeprecatedCreature encounter[ENCMAX];
	 int resist = 0;
	 clearmessagearea();
	 set_color_easy(WHITE_ON_BLACK_BRIGHT);
	 int attack = 0;
	 if (a.align != 1)
		 attack = a.attribute_roll(ATTRIBUTE_WISDOM) + t.get_attribute(ATTRIBUTE_WISDOM, false);
	 else //if (a.align == 1)
		 attack = a.attribute_roll(ATTRIBUTE_HEART) + t.get_attribute(ATTRIBUTE_HEART, false);

	 mvaddstrAlt(16, 1, getSpecialAttackString(a, t, resist, attack), gamelog);

	 gamelog.newline();
	 if ((t.animalgloss == ANIMALGLOSS_TANK || (t.animalgloss == ANIMALGLOSS_ANIMAL && lawList[LAW_ANIMALRESEARCH] != 2))
		 || (a.enemy() && t.flag & CREATUREFLAG_BRAINWASHED))
	 {
		 mvaddstrAlt(17, 1, t.name + (string)CONST_fight076, gamelog);
	 }
	 else if (a.align == t.align)
	 {
		 mvaddstrAlt(17, 1, t.name + (string)CONST_fight077 + a.name + singleDot);
	 }
	 else if (attack > resist)
	 {
		 t.stunned += (attack - resist) / 4;
		 if (a.enemy())
		 {
			 if (t.juice > 100)
			 {
				 mvaddstrAlt(17, 1, t.name + (string)CONST_fight078, gamelog);
				 addjuice(t, -50, 100);
			 }
			 else if (LCSrandom(15) > t.get_attribute(ATTRIBUTE_WISDOM, true) || t.get_attribute(ATTRIBUTE_WISDOM, true) < t.get_attribute(ATTRIBUTE_HEART, true))
			 {
				 mvaddstrAlt(17, 1, t.name + (string)CONST_fight079, gamelog);
				 t.adjust_attribute(ATTRIBUTE_WISDOM, +1);
			 }
			 else if (t.align == ALIGN_LIBERAL && t.flag & CREATUREFLAG_LOVESLAVE)
			 {
				 mvaddstrAlt(17, 1, t.name + (string)CONST_fight080, gamelog);
			 }
			 else
			 {
				 if (a.align == -1)
				 {
					 mvaddstrAlt(17, 1, t.name + (string)CONST_fight081, gamelog);
					 t.stunned = 0;
					 if (t.prisoner != NULL)
						 freehostage(t, 0);
					 addstrAlt(CONST_fight146, gamelog);
				 }
				 else
				 {
					 mvaddstrAlt(17, 1, t.name + (string)CONST_fight083, gamelog);
					 t.stunned = 0;
					 if (t.prisoner != NULL)
						 freehostage(t, 0);
					 addstrAlt(CONST_fight146, gamelog);
				 }
				 for (int e = 0; e < ENCMAX; e++)
				 {
					 if (encounter[e].exists == 0)
					 {
						 encounter[e] = t;
						 encounter[e].exists = 1;
						 if (a.align == -1)conservatise(encounter[e]);
						 encounter[e].cantbluff = 2;
						 encounter[e].squadid = -1;
						 break;
					 }
				 }
				 bool flipstart = 0;
				 for (int p = 0; p < 6; p++)
				 {
					 if (activesquad->squad[p] == &t)
					 {
						 activesquad->squad[p]->die();
						 activesquad->squad[p]->location = -1;
						 activesquad->squad[p] = NULL;
						 flipstart = 1;
					 }
					 if (flipstart&&p < 5) activesquad->squad[p] = activesquad->squad[p + 1];
				 }
				 if (flipstart) activesquad->squad[5] = NULL;
			 }
		 }
		 else
		 {
			 if (t.juice >= 100)
			 {
				 mvaddstrAlt(17, 1, t.name + (string)CONST_fight085, gamelog);
				 addjuice(t, -50, 99);
			 }
			 else if (!t.attribute_check(ATTRIBUTE_HEART, DIFFICULTY_AVERAGE) ||
				 t.get_attribute(ATTRIBUTE_HEART, true) < t.get_attribute(ATTRIBUTE_WISDOM, true))
			 {
				 mvaddstrAlt(17, 1, t.name + (string)CONST_fight086, gamelog);
				 t.adjust_attribute(ATTRIBUTE_HEART, +1);
			 }
			 else
			 {
				 mvaddstrAlt(17, 1, t.name + (string)CONST_fight087, gamelog);
				 t.stunned = 0;
				 liberalize(t);
				 t.infiltration /= 2;
				 t.flag |= CREATUREFLAG_CONVERTED;
				 t.cantbluff = 0;
			 }
		 }
	 }
	 else
	 {
		 mvaddstrAlt(17, 1, t.name + (string)CONST_fight088, gamelog);
	 }
	 gamelog.newline();
	 printparty();
	 if (mode == GAMEMODE_CHASECAR ||
		 mode == GAMEMODE_CHASEFOOT) printchaseencounter();
	 else printencounter();
	 pressAnyKey();
	 return;
 }
 /* modifies a combat roll based on the creature's critical injuries */
 void healthmodroll(int &aroll, DeprecatedCreature &a)
 {
	 if (a.special[SPECIALWOUND_RIGHTEYE] != 1) aroll -= LCSrandom(2);
	 if (a.special[SPECIALWOUND_LEFTEYE] != 1) aroll -= LCSrandom(2);
	 if (a.special[SPECIALWOUND_RIGHTEYE] != 1 &&
		 a.special[SPECIALWOUND_LEFTEYE] != 1) aroll -= LCSrandom(20);
	 if (a.special[SPECIALWOUND_RIGHTLUNG] != 1) aroll -= LCSrandom(8);
	 if (a.special[SPECIALWOUND_LEFTLUNG] != 1) aroll -= LCSrandom(8);
	 if (a.special[SPECIALWOUND_HEART] != 1) aroll -= LCSrandom(10);
	 if (a.special[SPECIALWOUND_LIVER] != 1) aroll -= LCSrandom(5);
	 if (a.special[SPECIALWOUND_STOMACH] != 1) aroll -= LCSrandom(5);
	 if (a.special[SPECIALWOUND_RIGHTKIDNEY] != 1) aroll -= LCSrandom(5);
	 if (a.special[SPECIALWOUND_LEFTKIDNEY] != 1) aroll -= LCSrandom(5);
	 if (a.special[SPECIALWOUND_SPLEEN] != 1) aroll -= LCSrandom(4);
	 if (a.special[SPECIALWOUND_LOWERSPINE] != 1) aroll -= LCSrandom(100);
	 if (a.special[SPECIALWOUND_UPPERSPINE] != 1) aroll -= LCSrandom(200);
	 if (a.special[SPECIALWOUND_NECK] != 1) aroll -= LCSrandom(300);
	 if (a.special[SPECIALWOUND_RIBS] < RIBNUM) aroll -= LCSrandom(5);
	 if (a.special[SPECIALWOUND_RIBS] < RIBNUM / 2) aroll -= LCSrandom(5);
	 if (a.special[SPECIALWOUND_RIBS] == 0) aroll -= LCSrandom(5);
 }
 /* adjusts attack damage based on armor, other factors */
 void damagemod(DeprecatedCreature &t, const char &damtype, int &damamount, int mod)
 {

	 if (mod > 10) mod = 10; // Cap damage multiplier (every 5 points adds 1x damage)
	 if (mod <= -20) damamount >>= 8;  //Cars plus heavy armor can be really tough.
	 else if (mod <= -14) damamount >>= 7;
	 else if (mod <= -8) damamount >>= 6;
	 else if (mod <= -6) damamount >>= 5;
	 else if (mod <= -4) damamount >>= 4;
	 else if (mod <= -3) damamount >>= 3;
	 else if (mod <= -2) damamount >>= 2;
	 else if (mod <= -1) damamount >>= 1;
	 else if (mod >= 0) damamount = (int)((float)damamount * (1.0f + 0.2f*mod));
	 // Firefighter's bunker gear reduces fire damage by 3/4
	 if ((damtype & WOUND_BURNED) && t.get_armor().has_fireprotection())
	 {
		 // Damaged gear isn't as effective as undamaged gear
		 if (t.get_armor().is_damaged())
			 damamount >>= 1; // Only half as much damage reduction
		 else
			 damamount >>= 2; // Full damage reduction
	 }
	 if (damamount < 0)damamount = 0;
 }
 map<short, string> tankBodyParts;
 map<short, string> animalBodyParts;
 map<short, string> humanBodyParts;
 std::string bodypartName(Bodyparts w, AnimalGlosses t) {
	 if (t == ANIMALGLOSS_TANK) {
		 if (tankBodyParts.count(w) > 0)
			 return tankBodyParts[w];
	 }
	 else if (t == ANIMALGLOSS_ANIMAL) {// FIXME: What about Six-legged Pigs?
		 if (animalBodyParts.count(w) > 0)
			 return animalBodyParts[w];
	 }
	 else {
		 if (humanBodyParts.count(w) > 0)
			 return humanBodyParts[w];
	 }
	 return CONST_fight089;
 }
 /* damages the selected armor if it covers the body part specified */
 void armordamage(Armor &armor, const int bp, const int damamount)
 {
	 if (armor.covers(bp) && LCSrandom(armor.get_durability()) < damamount)
	 {
		 if (armor.is_damaged())
		 {
			 armor.decrease_quality(LCSrandom(armor.get_durability()) < LCSrandom(damamount) / armor.get_quality() ? 1 : 0);
		 }
		 else
		 {
			 armor.set_damaged(true);
		 }
	 }
 }
 std::string burstHitString(int bursthits);
 /* blood explosions */
 void bloodblast(Armor* armor)
 {
	 extern short mode;
	 extern Deprecatedsquadst *activesquad;
	 extern coordinatest loc_coord;
	 extern DeprecatedCreature encounter[ENCMAX];
	 extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	 //GENERAL
	 if (armor != NULL)
		 armor->set_bloody(true);
	 if (mode != GAMEMODE_SITE)
		 return;
	 levelmap[loc_coord.locx][loc_coord.locy][loc_coord.locz].flag |= SITEBLOCK_BLOODY2;
	 //HIT EVERYTHING
	 for (int p = 0; p < 6; p++)
	 {
		 if (activesquad->squad[p] == NULL) continue;
		 if (!LCSrandom(2))
			 activesquad->squad[p]->get_armor().set_bloody(true);
	 }
	 for (int e = 0; e < ENCMAX; e++)
	 {
		 if (!encounter[e].exists) continue;
		 if (!LCSrandom(2))
			 encounter[e].get_armor().set_bloody(true);
	 }
	 //REFRESH THE SCREEN
	 printsitemap(loc_coord.locx, loc_coord.locy, loc_coord.locz);
	 refreshAlt();
 }
 /* destroys armor, masks, drops weapons based on severe damage */
 void severloot(DeprecatedCreature &cr)
 {
	 extern short mode;
	 extern Log gamelog;
	 int armok = 2;
	 if ((cr.wound[BODYPART_ARM_RIGHT] & WOUND_NASTYOFF) ||
		 (cr.wound[BODYPART_ARM_RIGHT] & WOUND_CLEANOFF)) armok--;
	 if ((cr.wound[BODYPART_ARM_LEFT] & WOUND_NASTYOFF) ||
		 (cr.wound[BODYPART_ARM_LEFT] & WOUND_CLEANOFF)) armok--;
	 if (cr.special[SPECIALWOUND_NECK] != 1) armok = 0;
	 if (cr.special[SPECIALWOUND_UPPERSPINE] != 1) armok = 0;
	 if (cr.is_armed() && armok == 0)
	 {
		 clearmessagearea();
		 set_color_easy(YELLOW_ON_BLACK_BRIGHT);
		 mvaddstrAlt(16, 1, tag_The, gamelog);
		 addstrAlt(cr.get_weapon().get_name(1), gamelog);
		 addstrAlt(CONST_fight090, gamelog);
		 mvaddstrAlt(17, 1, cr.name, gamelog);
		 addstrAlt(CONST_fight091, gamelog);
		 gamelog.newline();
		 pressAnyKey();
		 if (mode == GAMEMODE_SITE) cr.drop_weapons_and_clips(&groundloot);
		 else cr.drop_weapons_and_clips(NULL);
	 }
	 if ((((cr.wound[BODYPART_BODY] & WOUND_CLEANOFF) ||
		 (cr.wound[BODYPART_BODY] & WOUND_NASTYOFF)) &&
		 cr.get_armor().covers(BODYPART_BODY)) ||
		 ((cr.wound[BODYPART_HEAD] & WOUND_NASTYOFF) &&
			 cr.get_armor().is_mask()))
	 {
		 clearmessagearea();
		 set_color_easy(YELLOW_ON_BLACK_BRIGHT);
		 mvaddstrAlt(16, 1, cr.name, gamelog);
		 addstrAlt(CONST_fight136, gamelog);
		 addstrAlt(cr.get_armor().get_name(), gamelog);
		 addstrAlt(CONST_fight093, gamelog);
		 gamelog.newline();
		 pressAnyKey();
		 cr.strip(NULL);
	 }
 }
 /* describes a character's death */
 void adddeathmessage(DeprecatedCreature &cr)
 {
	 extern short mode;
	 extern Log gamelog;
	 extern short lawList[LAWNUM];
	 extern string slogan_str;
	 set_color_easy(YELLOW_ON_BLACK_BRIGHT);
	 char str[200];
	 char secondLine[200];
	 bool hasSecondLine = false;
	 strcpy(str, cr.name);
	 if ((cr.wound[BODYPART_HEAD] & WOUND_CLEANOFF) ||
		 (cr.wound[BODYPART_HEAD] & WOUND_NASTYOFF))
	 {
		 hasSecondLine = true;
		 switch (LCSrandom(4))
		 {
			 //TODO IsaacG Complete Migration of Strings
		 case 0:
			 strcat(str, CONST_fight094.c_str());
			 if (mode != GAMEMODE_CHASECAR)
				 strcpy(secondLine, CONST_fight095.c_str());
			 else strcpy(secondLine, CONST_fight096.c_str());
			 break;
		 case 1:
			 if (mode != GAMEMODE_CHASECAR)
				 strcat(str, CONST_fight097.c_str());
			 else strcat(str, CONST_fight098.c_str());
			 strcpy(secondLine, CONST_fight099.c_str());
			 break;
		 case 2:
			 strcat(str, CONST_fight100.c_str());
			 if (lawList[LAW_FREESPEECH] == -2)strcat(str, CONST_fight101.c_str());
			 else strcat(str, tag_blood.c_str());
			 strcat(str, CONST_fight102.c_str());
			 if (mode != GAMEMODE_CHASECAR)
				 strcpy(secondLine, CONST_fight103.c_str());
			 else strcpy(secondLine, CONST_fight104.c_str());
			 break;
		 case 3:
			 strcat(str, CONST_fight105.c_str());
			 strcpy(secondLine, CONST_fight106.c_str());
			 break;
		 }
	 }
	 else if ((cr.wound[BODYPART_BODY] & WOUND_CLEANOFF) ||
		 (cr.wound[BODYPART_BODY] & WOUND_NASTYOFF))
	 {
		 strcat(str, (singleSpace + pickrandom(body_falls_apart)).c_str());
	 }
	 else
	 {
		 hasSecondLine = true;
		 switch (LCSrandom(11))
		 {
		 case 0:
			 strcat(str, CONST_fight107.c_str());
			 if (lawList[LAW_FREESPEECH] == -2)strcpy(secondLine, CONST_fight108.c_str());
			 else strcpy(secondLine, CONST_fight109.c_str());
			 break;
		 case 1:
			 strcat(str, CONST_fight110.c_str());
			 if (lawList[LAW_FREESPEECH] == -2) strcpy(secondLine, CONST_fight111.c_str());
			 else strcpy(secondLine, CONST_fight112.c_str());
			 break;
		 case 2:
			 strcat(str, CONST_fight113.c_str());
			 switch (cr.align)
			 {
			 case ALIGN_LIBERAL:
			 case ALIGN_ELITELIBERAL:
				 strcpy(secondLine, slogan_str.c_str()); break;
			 case ALIGN_MODERATE:
				 strcpy(secondLine, CONST_fight114.c_str()); break;
			 default:
				 strcpy(secondLine, CONST_fightX05.c_str()); break;
			 }
			 break;
		 default:
			 vector<string> death = pickrandom(double_line_death);
			 strcat(str, (singleSpace + death[0]).c_str());
			 strcpy(secondLine, death[1].c_str());
			 break;
		 }
	 }
	 mvaddstrAlt(16, 1, str, gamelog);
	 if (hasSecondLine) {
		 mvaddstrAlt(17, 1, secondLine, gamelog);
	 }
	 gamelog.newline();
 }
 /* attack handling for an individual creature and its target */
 // returns a boolean representing whether it was the intended target or CONST_fight116
 // so bool actual does not need to be passed by reference
 bool attack(DeprecatedCreature &a, DeprecatedCreature &t, const char mistake, const bool force_melee = false);

 bool attemptSpecialAttack(DeprecatedCreature &a, DeprecatedCreature &t, const bool force_melee) {
	 extern DeprecatedCreature encounter[ENCMAX];
	 //SPECIAL ATTACK!
	 int encnum = 0;
	 for (int e = 0; e < ENCMAX; e++) if (encounter[e].exists) encnum++;
	 bool specialAttackIsPossible = (!force_melee &&
		 (((a.type == CREATURE_COP && a.align == ALIGN_MODERATE && a.enemy()) ||
			 a.type == CREATURE_SCIENTIST_EMINENT ||
			 a.type == CREATURE_JUDGE_LIBERAL ||
			 a.type == CREATURE_JUDGE_CONSERVATIVE ||
			 (a.type == CREATURE_CORPORATE_CEO && LCSrandom(2)) ||
			 a.type == CREATURE_POLITICIAN ||
			 a.type == CREATURE_RADIOPERSONALITY ||
			 a.type == CREATURE_NEWSANCHOR ||
			 a.type == CREATURE_MILITARYOFFICER ||
			 a.get_weapon().get_specific_bool(BOOL_MUSICAL_ATTACK_)) &&
			 (a.get_weapon().get_specific_bool(BOOL_MUSICAL_ATTACK_) || !a.is_armed() || a.align != 1)));
	 if (specialAttackIsPossible)
	 {
		 if (a.align == 1 || encnum < ENCMAX)
		 {
			 specialattack(a, t);
			 return true;
		 }
	 }
	 return false;
 }
 bool attemptReload(DeprecatedCreature &a, const bool force_melee) {
	 extern short mode;
	 extern Log gamelog;
	 //RELOAD
	 if ((a.will_reload(mode == GAMEMODE_CHASECAR, force_melee)
		 || (a.has_thrown_weapon && len(a.extra_throwing_weapons)))
		 && !force_melee)
	 {
		 char str[200];
		 if (a.will_reload(mode == GAMEMODE_CHASECAR, force_melee))
		 {
			 a.reload(false);
			 strcpy(str, a.name);
			 strcat(str, CONST_fight117.c_str());
		 }
		 else if (a.has_thrown_weapon && len(a.extra_throwing_weapons))
		 {
			 a.ready_another_throwing_weapon();
			 strcpy(str, a.name);
			 strcat(str, CONST_fight118.c_str());
			 strcat(str, a.get_weapon().get_name().c_str());
			 strcat(str, singleDot.c_str());
		 }
		 mvaddstrAlt(16, 1, str, gamelog);
		 gamelog.newline();
		 printparty();
		 if (mode == GAMEMODE_CHASECAR
			 || mode == GAMEMODE_CHASEFOOT) printchaseencounter();
		 else printencounter();
		 pressAnyKey();
		 return true;
	 }
	 else if (a.has_thrown_weapon) a.has_thrown_weapon = false;
	 return false;
 }
 bool attemptIncapacitated(DeprecatedCreature &a) {
	 extern short mode;
	 //INCAPACITATED
	 char incaprint;
	 a.forceinc = 0;
	 if (incapacitated(a, 0, incaprint))
	 {
		 if (incaprint)
		 {
			 printparty();
			 if (mode == GAMEMODE_CHASECAR ||
				 mode == GAMEMODE_CHASEFOOT) printchaseencounter();
			 else printencounter();
			 pressAnyKey();
		 }
		 a.forceinc = 1;
		 return true;
	 }
	 return false;
 }

 string showMultipleHits(DeprecatedCreature &a, const int bursthits, const attackst* attack_used) {
	 string str;
	 // show multiple hits
	 if (bursthits > 1 && a.is_armed()) // Only show if not melee
	 {
		 str = commaSpace;
		 if (!a.is_armed()) //Move into WEAPON_NONE? -XML
		 {
			 str += CONST_fight137;
		 }
		 else {
			 str += attack_used->hit_description;
		 }
		 str += burstHitString(bursthits);
	 }
	 else if (attack_used->always_describe_hit)
	 {
		 str += commaSpace;
		 str += attack_used->hit_description;
	 }
	 return str;
 }
 DeprecatedCreature* takeBulletForLeader(DeprecatedCreature &t, const int damamount, const int w) {
	 extern Log gamelog;
	 extern Deprecatedsquadst *activesquad;
	 DeprecatedCreature* target = 0;
	 if (t.squadid != -1 && t.hireid == -1 && //if the founder is hit...
		 (damamount > t.blood || damamount >= 10) && //and lethal or potentially crippling damage is done...
		 (w == BODYPART_HEAD || w == BODYPART_BODY)) //to a critical bodypart...
	 {
		 //Oh Noes!!!! Find a liberal to jump in front of the bullet!!!
		 for (int i = 0; i < 6; i++)
		 {
			 if (activesquad->squad[i] == NULL) break;
			 if (activesquad->squad[i] == &t) break;
			 if (activesquad->squad[i]->get_attribute(ATTRIBUTE_HEART, true) > 8 &&
				 activesquad->squad[i]->get_attribute(ATTRIBUTE_AGILITY, true) > 4)
			 {
				 target = activesquad->squad[i];
				 clearmessagearea();
				 set_color_easy(GREEN_ON_BLACK_BRIGHT);
				 mvaddstrAlt(16, 1, target->name, gamelog);
				 if (!t.alive) addstrAlt(CONST_fight142, gamelog);
				 else addstrAlt(CONST_fight143, gamelog);
				 addstrAlt(CONST_fight144, gamelog);
				 addstrAlt(t.name, gamelog);
				 if (!t.alive) addstrAlt(CONST_fight145, gamelog);
				 addstrAlt(CONST_fight146, gamelog);
				 gamelog.newline();
				 addjuice(*target, 10, 1000);//Instant juice!! Way to take the bullet!!
				 pressAnyKey();
				 break;
			 }
		 }
	 }
	 return target;
 }

 int determineBodypartHit(DeprecatedCreature &t, const int aroll, const int droll, const bool sneak_attack) {

	 bool canhit = false;
	 for (int w = 0; w < BODYPARTNUM && !canhit; w++)
	 {
		 if (!(t.wound[w] & WOUND_CLEANOFF) && !(t.wound[w] & WOUND_NASTYOFF))
		 {
			 canhit = true;
		 }
	 }
	 int w;
	 do
	 {
		 int offset = 0;
		 if (aroll > droll + 5)
			 offset = 4;  // NICE SHOT; MORE LIKELY TO HIT BODY/HEAD
		 if (aroll > droll + 10 &&
			 (!(t.wound[BODYPART_HEAD] & (WOUND_CLEANOFF | WOUND_NASTYOFF)) ||
				 !(t.wound[BODYPART_BODY] & (WOUND_CLEANOFF | WOUND_NASTYOFF))))
			 offset = 8;  // NO LIMB HITS HERE YOU AWESOME PERSON
		 if (sneak_attack)
			 offset = 10; // Backstab! 2/3 body, 1/3 head
		 if (aroll > droll + 15 &&
			 !(t.wound[BODYPART_HEAD] & (WOUND_CLEANOFF | WOUND_NASTYOFF)))
			 offset = 12; // BOOM AUTOMATIC HEADSHOT MOTHA******
						  //Weighted location roll:
						  //200% chance to hit body
						  //50% chance to hit head
		 w = offset + LCSrandom(13 - offset);
		 switch (w)
		 {
		 case 12:w = BODYPART_HEAD; break;
		 case 11:
		 case 10:
		 case 9:
		 case 8:w = BODYPART_BODY; break;
		 case 7:
		 case 3:w = BODYPART_ARM_RIGHT; break;
		 case 6:
		 case 2:w = BODYPART_ARM_LEFT; break;
		 case 5:
		 case 1:w = BODYPART_LEG_RIGHT; break;
		 case 4:
		 case 0:w = BODYPART_LEG_LEFT; break;
		 }
	 } while (((t.wound[w] & WOUND_CLEANOFF) || (t.wound[w] & WOUND_NASTYOFF)) && canhit == true);
	 return w;
 }
 string printSpecialWounds(DeprecatedCreature* target, const int w, const int damamount, const int damtype) {

	 char heavydam = 0, breakdam = 0, pokedam = 0;
	 if (damamount >= 12) //JDS -- 2x damage needed
	 {
		 if (damtype & WOUND_SHOT || damtype & WOUND_BURNED || damtype & WOUND_TORN || damtype & WOUND_CUT) heavydam = 1;
	 }
	 if (damamount >= 10) //JDS -- 2x damage needed
	 {
		 if (damtype & WOUND_SHOT || damtype & WOUND_TORN || damtype & WOUND_CUT) pokedam = 1;
	 }
	 if ((damtype & WOUND_BRUISED || damtype & WOUND_SHOT || damtype & WOUND_TORN || damtype & WOUND_CUT) && damamount >= 50) {
		 breakdam = 1;
	 }
	 string damageDescription;
	 switch (w) {
	 case BODYPART_HEAD:
		 damageDescription = specialWoundPossibilityHead(
			 *target,
			 breakdam,
			 heavydam,
			 damtype
		 );
		 break;
	 case BODYPART_BODY:
		 string damageDescription = specialWoundPossibilityBody(
			 *target,
			 breakdam,
			 pokedam,
			 damtype
		 );
		 break;
	 }
	 return damageDescription;

 }


 char consolidateDamageTypesNotCutOrBruised(const attackst* attack_used) {
	 char damtype = 0;
	 if (attack_used->burns) damtype |= WOUND_BURNED;
	 if (attack_used->tears) damtype |= WOUND_TORN;
	 if (attack_used->shoots) damtype |= WOUND_SHOT;
	 if (attack_used->bleeding) damtype |= WOUND_BLEEDING;
	 return damtype;
 }

 char consolidateDamageTypes(const attackst* attack_used) {
	 char damtype = 0;
	 if (attack_used->bruises) damtype |= WOUND_BRUISED;
	 if (attack_used->cuts) damtype |= WOUND_CUT;
	 damtype |= consolidateDamageTypesNotCutOrBruised(attack_used);
	 return damtype;
 }

 void setSiteAlarmOne();
 string howGracefulAttack(int handToHand);
 string initiateCombat(const DeprecatedCreature a, const bool sneak_attack, const attackst* attack_used) {


	 string str;

	 if (!a.is_armed())
	 {
		 if (!a.animalgloss) //Move into WEAPON_NONE -XML
		 {
			 str += howGracefulAttack(a.get_skill(SKILL_HANDTOHAND));
		 }
		 else
		 {
			 if (a.specialattack == ATTACK_CANNON)
			 {
				 str += CONST_fight127;
			 }
			 else if (a.specialattack == ATTACK_FLAME) str += CONST_fight128;
			 else if (a.specialattack == ATTACK_SUCK) str += CONST_fight129;
			 else str += CONST_fight130;
		 }
	 }
	 else
	 {

		 if (sneak_attack)
		 {
			 str += CONST_fight131;
		 }
		 else {
			 str += attack_used->attack_description;
			 setSiteAlarmOne();
		 }
	 }
	 return str;
 }

 string unsuccessfulHit(DeprecatedCreature &a, DeprecatedCreature &t, const int droll) {

	 extern short mode;

	 string str;

	 if (mode == GAMEMODE_CHASECAR)
	 {
		 DeprecatedCreature* driver = getChaseDriver(t);
		 str = driver->name;
		 if (droll == 1) {
			 str = a.name;
			 str += CONST_fight158;
		 }
		 else if (droll == 2) {
			 str = a.name;
			 str += CONST_fight159;
		 }
		 else if (droll > 18 || droll < 1) {
			 str = a.name;
			 str += CONST_fight160;  // You failed to hit someone who probably rolled a zero.  You should feel bad.
		 }
		 else {
			 str += evasionStringsAlt[droll - 3];
		 }
	 }
	 else {
		 str = t.name;
		 if (droll == 1) {
			 str = a.name;
			 str += CONST_fight158;
		 }
		 else if (droll == 2) {
			 str = a.name;
			 str += CONST_fight159;
		 }
		 else if (droll > 18 || droll < 1) {
			 str = a.name;
			 str += CONST_fight160;  // You failed to hit someone who probably rolled a zero.  You should feel bad.
		 }
		 else {
			 str += evasionStrings[droll - 3];
		 }
	 }
	 return str;

 }
 string dismemberingWound(const int w, const int wound);
 int bodypartSeverAmount(const int w);

 class AttackInfliction {
 public:
	 AttackInfliction(const bool, const int, const int, const attackst*);
	 const bool sneak_attack;
	 const int aroll;
	 const int droll;
	 const attackst* attack_used;
 };
 AttackInfliction::AttackInfliction(const bool _sneak_attack, const int _aroll, const int _droll, const attackst* _attack_used) : sneak_attack(_sneak_attack), aroll(_aroll < 0 ? 0 : _aroll),
	 droll(_droll < 0 ? 0 : _droll),
	 attack_used(_attack_used) {


 }
 class AttackSeverity {
 public:
	 AttackSeverity::AttackSeverity(const int, const int, const int, const int);
	 const int damamount;
	 const int damagearmor;
	 const int severtype;
	 const int hit_location;

 };
 AttackSeverity::AttackSeverity(const int _damamount, const int _damagearmor, const int _severtype, const int w) : damamount(_damamount),
	 damagearmor(_damagearmor),
	 severtype(_severtype),
	 hit_location(w)
 {


 }
 void inflictNonZeroDamage(AttackInfliction attackI,
	 DeprecatedCreature &a,
	 const string inputStr,
	 const AttackSeverity attackS,
	 const int damtype,
	 DeprecatedCreature &t)
 {
	 const int damagearmor = attackS.damagearmor;
	 const int severtype = attackS.severtype;
	 const int totalDamage = attackS.damamount;
	 const int w = attackS.hit_location;
	 const bool sneak_attack = attackI.sneak_attack;
	 const attackst* attack_used = attackI.attack_used;

	 // TODO not all these externs are necessary
	 extern short mode;
	 extern int stat_dead;
	 extern int stat_kills;
	 extern int ccs_siege_kills;
	 extern int ccs_boss_kills;
	 extern Log gamelog;
	 extern Deprecatednewsstoryst *sitestory;

	 extern int sitecrime;
	 extern short cursite;
	 extern coordinatest loc_coord;
	 extern short sitealarmtimer;
	 extern siteblockst levelmap[MAPX][MAPY][MAPZ];
	 extern short lawList[LAWNUM];

	 // These two variables are used and changed within this function, but are never used again by the function that calls this one
	 string str = inputStr;
	 int damamount = totalDamage;

	 DeprecatedCreature *target = takeBulletForLeader(t, damamount, w);
	 if (!target) target = &t;//If nobody jumps in front of the attack,
	 target->wound[w] |= damtype;
	 int severamount = bodypartSeverAmount(w);
	 if (severtype != -1 && damamount >= severamount)
		 target->wound[w] |= (char)severtype;
	 if (w != BODYPART_HEAD && w != BODYPART_BODY && target->blood - damamount <= 0 &&
		 target->blood > 0)
	 {
		 do
		 {
			 if (LCSrandom(100) < attack_used->no_damage_reduction_for_limbs_chance)
				 break;
			 else damamount >>= 1;
		 } while (target->blood - damamount <= 0);
	 }
	 if (damagearmor) armordamage(target->get_armor(), w, damamount); {
		 target->blood -= damamount;
	 }
	 levelmap[loc_coord.locx][loc_coord.locy][loc_coord.locz].flag |= SITEBLOCK_BLOODY;

	 string hit_punctuation = attack_used->hit_punctuation;
	 string dismembered = dismemberingWound(w, target->wound[w]);
	 if (len(dismembered)) {
		 hit_punctuation = dismembered;
	 }
	 str += hit_punctuation;

	 if ((target->wound[BODYPART_HEAD] & (WOUND_CLEANOFF | WOUND_NASTYOFF)) ||
		 (target->wound[BODYPART_BODY] & (WOUND_CLEANOFF | WOUND_NASTYOFF)) ||
		 target->blood <= 0)
	 {
		 if ((w == BODYPART_HEAD && target->wound[BODYPART_HEAD] & WOUND_NASTYOFF) ||
			 (w == BODYPART_BODY && target->wound[BODYPART_BODY] & WOUND_NASTYOFF)) {
			 bloodblast(&target->get_armor());
		 }
		 const char alreadydead = !target->alive; // This tests whether the person being fatally wounded was a corpse
		 if (!alreadydead)
		 {
			 target->die();
			 if (t.align == -a.align)
				 addjuice(a, 5 + t.juice / 20, 1000); // Instant juice
			 else addjuice(a, -(5 + t.juice / 20), -50);
			 if (target->squadid != -1)
			 {
				 if (target->align == 1) stat_dead++;
			 }
			 else if (target->enemy() && (t.animalgloss != ANIMALGLOSS_ANIMAL || lawList[LAW_ANIMALRESEARCH] == 2))
			 {
				 stat_kills++;
				 if (LocationsPool::getInstance().isThereASiegeHere(cursite)) LocationsPool::getInstance().addSiegeKill(cursite);
				 if (LocationsPool::getInstance().isThereASiegeHere(cursite) && t.animalgloss == ANIMALGLOSS_TANK) LocationsPool::getInstance().removeTank(cursite);
				 if (LocationsPool::getInstance().get_specific_integer(INT_GETRENTINGTYPE,cursite) == RENTING_CCS)
				 {
					 if (target->type == CREATURE_CCS_ARCHCONSERVATIVE) ccs_boss_kills++;
					 ccs_siege_kills++;
				 }
			 }
			 if (target->squadid == -1 &&
				 (target->animalgloss != ANIMALGLOSS_ANIMAL || lawList[LAW_ANIMALRESEARCH] == 2) &&
				 !sneak_attack)
			 {
				 sitecrime += 10;
				 sitestory->crime.push_back(CRIME_KILLEDSOMEBODY);
				 if (a.squadid != -1) criminalizeparty(LAWFLAG_MURDER);
			 }
		 }
		 //set_color_easy(WHITE_ON_BLACK_BRIGHT);
		 if (goodguyattack) { set_color_easy(GREEN_ON_BLACK_BRIGHT); }
		 else { set_color_easy(RED_ON_BLACK_BRIGHT); }

		 mvaddstrAlt(17, 1, str, gamelog);
		 gamelog.newline();
		 pressAnyKey();
		 if (!alreadydead)
		 {
			 severloot(t);
			 clearmessagearea();
			 adddeathmessage(*target);
			 pressAnyKey();
			 if (target->prisoner != NULL) freehostage(t, 1);
		 }
	 }
	 else
	 {
		 if (target->wound[w] & WOUND_NASTYOFF) bloodblast(&target->get_armor());
		 if (goodguyattack) set_color_easy(GREEN_ON_BLACK_BRIGHT);
		 else set_color_easy(RED_ON_BLACK_BRIGHT);
		 //set_color_easy(WHITE_ON_BLACK_BRIGHT);
		 mvaddstrAlt(17, 1, str, gamelog);
		 gamelog.newline();
		 printparty();
		 if (mode == GAMEMODE_CHASECAR ||
			 mode == GAMEMODE_CHASEFOOT) printchaseencounter();
		 else printencounter();
		 pressAnyKey();
		 //SPECIAL WOUNDS
		 string damageDescription;
		 if (!(target->wound[w] & (WOUND_CLEANOFF | WOUND_NASTYOFF)) &&
			 !target->animalgloss)
		 {
			 damageDescription = printSpecialWounds(target, w, damamount, damtype);
			 severloot(*target);
		 }
		 if (len(damageDescription) > 0) {
			 clearmessagearea();
			 if (goodguyattack) set_color_easy(GREEN_ON_BLACK_BRIGHT);
			 else set_color_easy(RED_ON_BLACK_BRIGHT);
			 mvaddstrAlt(16, 1, damageDescription, gamelog);
			 gamelog.newline();
			 pressAnyKey();
		 }
		 //set_color_easy(WHITE_ON_BLACK_BRIGHT);
	 }
 }

 int couldVehicleHaveBlockedAttack(const int mod, const  int armor, const char damtype,
	 const int armorpiercing, const int car_dmg) {
	 // Could the vehicle have bounced that round on its own?
	 int cardmg = car_dmg;

	 DeprecatedCreature testDummy; // Spawn nude test dummy to see if body armor was needed to prevent damage
	 int mod3 = mod;

	 const int mod2 = armor + LCSrandom(armor + 1) - armorpiercing;
	 if (mod2 > 0) mod3 -= mod2 * 2;
	 damagemod(testDummy, damtype, cardmg, mod3);

	 return cardmg;
 }
 int couldTankHaveBlockedAttack(const int mod, const char damtype,
	 const int armorpiercing, const int car_dmg) {
	 int armor;
	 if (damtype != WOUND_BURNED) armor = 15;
	 else armor = 10;
	 // Could the vehicle have bounced that round on its own?
	 int cardmg = car_dmg;
	 DeprecatedCreature testDummy; // Spawn nude test dummy to see if body armor was needed to prevent damage
	 int mod3 = mod;

	 const int mod2 = armor + LCSrandom(armor + 1) - armorpiercing;
	 if (mod2 > 0) mod3 -= mod2 * 2;
	 damagemod(testDummy, damtype, cardmg, mod3);

	 return cardmg;
 }
 void defineIfDefined(const attackst* attack_used, int &random, int &fixed, int &severtype) {
	 if (attack_used->critical.random_damage_defined)
		 random = attack_used->critical.random_damage;
	 if (attack_used->critical.fixed_damage_defined)
		 fixed = attack_used->critical.fixed_damage;
	 if (attack_used->critical.severtype_defined)
		 severtype = attack_used->critical.severtype;
 }
 string bouncesOffCar(const Vehicle* vehicle, const int vehicleHitLocation) {
	 string str = CONST_fight139;

	 str += (CONST_fight140 + vehicle->shortname() + CONST_fight136);
	 str += vehicle->getpartname(vehicleHitLocation);

	 return str;
 }
 void inflictDamage(const int numhits, DeprecatedCreature &a, DeprecatedCreature &t, const AttackInfliction attackI) {
	 const int aroll = attackI.aroll;
	 const int droll = attackI.droll;
	 const bool sneak_attack = attackI.sneak_attack;
	 const attackst* attack_used = attackI.attack_used;

	 extern short mode;
	 extern Log gamelog;

	 int bursthits = numhits;

	 int w = determineBodypartHit(t, aroll, droll, sneak_attack);


	 char damtype = 0;
	 int damamount = 0;
	 char strengthmin = 1;
	 char strengthmax = 1;
	 int severtype = -1;
	 char damagearmor = 0;
	 char armorpiercing = 0;
	 int extraarmor = 0;
	 if (!a.is_armed())
	 {
		 strengthmin = 5;
		 strengthmax = 10;
		 for (; bursthits > 0; bursthits--) //Put into WEAPON_NONE -XML
		 {
			 damamount += LCSrandom(5 + a.get_skill(SKILL_HANDTOHAND)) + 1 + a.get_skill(SKILL_HANDTOHAND);
		 }
		 if (!a.animalgloss) damtype |= WOUND_BRUISED;
		 else
		 {
			 switch (a.specialattack) {
			 case ATTACK_CANNON:
				 damamount = LCSrandom(5000) + 5000;
				 armorpiercing = 20;

				 damtype |= consolidateDamageTypesNotCutOrBruised(attack_used);

				 strengthmin = 0;
				 strengthmax = 0;
				 break;

			 case ATTACK_FLAME:
				 damtype |= WOUND_BURNED;
				 break;

			 case ATTACK_SUCK:
				 damtype |= WOUND_CUT;
				 break;

			 default:
				 damtype |= WOUND_TORN;
				 break;
			 }
			 severtype = WOUND_NASTYOFF;
		 }
	 }
	 else
	 {
		 damtype |= consolidateDamageTypes(attack_used);
		 strengthmin = attack_used->strength_min;
		 strengthmax = attack_used->strength_max;
		 severtype = attack_used->severtype;
		 int random = attack_used->random_damage;
		 int fixed = attack_used->fixed_damage;
		 if (sneak_attack) fixed += 100;
		 if (bursthits >= attack_used->critical.hits_required
			 && LCSrandom(100) < attack_used->critical.chance)
		 {
			 defineIfDefined(attack_used, random, fixed, severtype);
		 }
		 for (; bursthits > 0; bursthits--)
		 {
			 damamount += LCSrandom(random) + fixed;
		 }
		 damagearmor = attack_used->damages_armor;
		 armorpiercing = attack_used->armorpiercing;
	 }
	 // Coarse combat lethality reduction.
	 //damamount/=2;
	 if (t.squadid != -1 && t.hireid == -1) // Plot Armor: if the founder is hit, inflict
		 damamount /= 2;                // 1/2 damage, because founders are cool
	 int mod = 0;
	 if (strengthmax > strengthmin)
	 {
		 // Melee attacks: Maximum strength bonus, minimum
		 // strength to deliver full damage
		 int strength = a.attribute_roll(ATTRIBUTE_STRENGTH);
		 if (strength > strengthmax) strength = (strengthmax + strength) / 2;
		 mod += strength - strengthmin;
		 armorpiercing += (strength - strengthmin) / 4;
	 }
	 //SKILL BONUS FOR GOOD ROLL
	 mod += aroll - droll;
	 //DO THE HEALTH MOD ON THE WOUND
	 mod -= t.attribute_roll(ATTRIBUTE_HEALTH);
	 //Health and poor accuracy will only avoid critical hits, not stop low-damage attacks
	 if (mod < 0) mod = 0;
	 // In a car chase, the vehicle itself provides bonus armor
	 int vehicleHitLocation = 0;
	 Vehicle* vehicle = getChaseVehicle(t);
	 if (mode == GAMEMODE_CHASECAR && vehicle != NULL)
	 {
		 vehicleHitLocation = vehicle->gethitlocation(w);
		 extraarmor = vehicle->armorbonus(vehicleHitLocation);
		 // TODO damage vehicle itself
	 }
	 int cardmg = damamount;
	 {
		 int mod3 = mod;
		 int armor = t.get_armor().get_armor(w);
		 if (t.animalgloss == ANIMALGLOSS_TANK)
		 {
			 if (damtype != WOUND_BURNED) armor = 15;
			 else armor = 10;
		 }
		 //if(t.get_armor().get_quality()>1)
		 armor -= t.get_armor().get_quality() - 1;
		 if (t.get_armor().is_damaged())
			 armor -= 1;
		 if (armor < 0) armor = 0; // Possible from second-rate clothes
		 armor += extraarmor; // Add vehicle armor 
		 const int mod2 = armor + LCSrandom(armor + 1) - armorpiercing;
		 if (mod2 > 0) mod3 -= mod2 * 2;
		 damagemod(t, damtype, damamount, mod3);
	 }

	 string str;
	 if ((damamount == 0) && (mode == GAMEMODE_CHASECAR && vehicle != NULL && extraarmor > 0))
	 {

		 if ((t.animalgloss == ANIMALGLOSS_TANK)) {
			 cardmg = couldTankHaveBlockedAttack(mod, damtype,
				 armorpiercing, cardmg);
		 }
		 else {
			 int armor = t.get_armor().get_armor(w);
			 //if(t.get_armor().get_quality()>1)
			 armor -= t.get_armor().get_quality() - 1;
			 if (t.get_armor().is_damaged())
				 armor -= 1;
			 if (armor < 0) armor = 0; // Possible from second-rate clothes
			 armor += extraarmor; // Add vehicle armor 

			 cardmg = couldVehicleHaveBlockedAttack(mod, armor, damtype,
				 armorpiercing, cardmg);
		 }
		 if (cardmg < 2) //fudge factor of 1 armor level due to randomness
		 {
			 str = bouncesOffCar(vehicle, vehicleHitLocation);
		 }
	 }

	 if (len(str) < 1) {
		 str = a.heshe(true); // capitalize=true. Shorten the string so it doesn't spill over as much; we already said attacker's name on the previous line anyways.
		 if (sneak_attack) str += CONST_fight134;
		 else str += CONST_fight135;
		 str += t.name;
		 str += CONST_fight136;
		 str += bodypartName((Bodyparts)w, (AnimalGlosses)t.animalgloss);
		 str += showMultipleHits(a, bursthits, attack_used);
		 // Report vehicle protection effect
		 if (mode == GAMEMODE_CHASECAR && vehicle != NULL && extraarmor > 0)
		 {
			 str += CONST_fight138;

			 str += (CONST_fight140 + vehicle->shortname() + CONST_fight136);
			 str += vehicle->getpartname(vehicleHitLocation);
		 }
	 }

	 // Bullets caught by armor should bruise instead of poke holes.
	 if (damamount < 4 && damtype & WOUND_SHOT)
	 {
		 damtype &= ~(WOUND_SHOT | WOUND_BLEEDING);
		 damtype |= WOUND_BRUISED;
	 }
	 if (damamount > 0)
	 {
		 AttackSeverity attackS(damamount, damagearmor, severtype, w);
		 inflictNonZeroDamage(attackI,
			 a,
			 str,
			 attackS,
			 damtype,
			 t);

	 }
	 else
	 {
		 set_color_easy(YELLOW_ON_BLACK_BRIGHT);
		 str += CONST_fight153;
		 mvaddstrAlt(17, 1, str, gamelog);
		 gamelog.newline();
		 printparty();
		 if (mode == GAMEMODE_CHASECAR ||
			 mode == GAMEMODE_CHASEFOOT) printchaseencounter();
		 else printencounter();
		 pressAnyKey();
	 }
 }
 void addLocationChange(int cursite, sitechangest change);
 void directlyUseWeapon(DeprecatedCreature &a, int &num_attacks, int &thrownweapons, int &bursthits, const attackst* attack_used) {

	 extern short mode;

	 extern Deprecatednewsstoryst *sitestory;

	 extern int sitecrime;
	 extern short cursite;
	 extern coordinatest loc_coord;

	 extern siteblockst levelmap[MAPX][MAPY][MAPZ];

	 if (mode == GAMEMODE_SITE && LCSrandom(100) < attack_used->fire.chance_causes_debris)
	 {// TODO - In a car chase, debris should make driving harder for one round, or require a drive skill check to avoid damage
		 sitechangest change(loc_coord.locx, loc_coord.locy, loc_coord.locz, SITEBLOCK_DEBRIS);
		 addLocationChange(cursite, change);//  location[cursite]->changes.push_back(change);
	 }
	 if (mode == GAMEMODE_SITE && LCSrandom(100) < attack_used->fire.chance)
	 {// TODO - In a car chase, apply vehicle damage, with drive skill check to partially mitigate
	  // Fire!
		 if (!(levelmap[loc_coord.locx][loc_coord.locy][loc_coord.locz].flag & SITEBLOCK_FIRE_END) ||
			 !(levelmap[loc_coord.locx][loc_coord.locy][loc_coord.locz].flag & SITEBLOCK_FIRE_PEAK) ||
			 !(levelmap[loc_coord.locx][loc_coord.locy][loc_coord.locz].flag & SITEBLOCK_FIRE_START) ||
			 !(levelmap[loc_coord.locx][loc_coord.locy][loc_coord.locz].flag & SITEBLOCK_DEBRIS))
		 {
			 levelmap[loc_coord.locx][loc_coord.locy][loc_coord.locz].flag |= SITEBLOCK_FIRE_START;
			 sitecrime += 3;
			 addjuice(a, 5, 500);
			 criminalizeparty(LAWFLAG_ARSON);
			 sitestory->crime.push_back(CRIME_ARSON);
		 }
	 }

	 if (attack_used->thrown)
	 {
		 thrownweapons = num_attacks;
		 if (thrownweapons > a.count_weapons()) {
			 thrownweapons = a.count_weapons();
			 num_attacks = thrownweapons;
		 }
	 }
	 else
		 if (attack_used->uses_ammo) {
			 if (a.get_weapon().get_ammoamount() < num_attacks) {
				 num_attacks = a.get_weapon().get_ammoamount();
			 }
			 a.get_weapon().decrease_ammo(num_attacks);
		 }

 }
 string firstStrike(const DeprecatedCreature a, const DeprecatedCreature t, const char mistake, const bool sneak_attack, const attackst* attack_used) {
	 string str = a.name;

	 str += singleSpace;
	 if (mistake) { str += CONST_fight119; }
	 str += initiateCombat(a, sneak_attack, attack_used);
	 str += singleSpace;
	 str += t.name;

	 if (a.is_armed() && !attack_used->thrown)
	 {
		 str += CONST_fight132;
		 str += a.get_weapon().get_name(1);
	 }

	 str += CONST_fight146;
	 return str;
 }
 int driverAttackBonus(const DeprecatedCreature a) {

	 DeprecatedCreature* adriver = getChaseDriver(a);
	 Vehicle* avehicle = getChaseVehicle(a);

	 if (adriver != NULL && avehicle != NULL)
	 {
		 return avehicle->attackbonus(adriver->id == a.id);  // Attack bonus depends on attacker's car and whether attacker is distracted by driving.
	 }
	 else // shouldn't happen
	 {
		 return -10; // You're on the wrong side of a drive-by shooting?!
	 }

 }
 int driverDodgeSkill(const DeprecatedCreature t) {

	 DeprecatedCreature* driver = getChaseDriver(t);
	 Vehicle* vehicle = getChaseVehicle(t);

	 if (driver != NULL && vehicle != NULL)
	 {  // without a vehicle or driver, you get a zero roll.
		 return driver->skill_roll(PSEUDOSKILL_DODGEDRIVE);
	 }
	 else {
		 return 0;
	 }
 }
 void trainDodgeDriveAndAttack(DeprecatedCreature &a, DeprecatedCreature &t, const int droll, const int aroll, const int weapon_skill) {
	 DeprecatedCreature* driver = getChaseDriver(t);

	 if (driver != NULL)
		 driver->train(SKILL_DRIVING, aroll / 2);
	 else
		 t.train(SKILL_DODGE, aroll * 2);
	 a.train(weapon_skill, droll * 2 + 5);
 }
 void driverHealthModRoll(int &droll, const DeprecatedCreature t) {
	 DeprecatedCreature* driver = getChaseDriver(t);

	 if (driver != NULL)
	 {// if there is no driver, we already rolled a zero, so don't worry about further penalties.
		 healthmodroll(droll, *driver);
	 }
 }

 bool attackPoolEncounter(const int p, const int t, const char mistake, const bool force_melee) {
	 extern DeprecatedCreature encounter[ENCMAX];
	 extern vector<DeprecatedCreature *> pool;
	 return attack(*pool[p], encounter[t], mistake, force_melee);
 }

bool attackPoolEncounter(const int p, const int t, const char mistake, const bool force_melee = false);
void addLocationChange(int cursite, sitechangest change);
bool isThereASiteAlarm();
/* attack handling for an individual creature and its target */
bool attack(DeprecatedCreature &a, DeprecatedCreature &t, const char mistake, const bool force_melee)
{
	extern short mode;
	extern Log gamelog;
	extern short cursite;
	extern short sitealarmtimer;

	clearmessagearea(true);  // erase the whole length and redraw map if applicable, since previous combat messages can be wider than 53 chars.
	if (goodguyattack) set_color_easy(GREEN_ON_BLACK_BRIGHT);
	else set_color_easy(RED_ON_BLACK_BRIGHT);

	const attackst* attack_used = a.get_weapon().get_attack(mode == GAMEMODE_CHASECAR,          //Force ranged if in a car.
		force_melee,
		(force_melee || !a.can_reload())); //No reload if force melee or unable to reload.
	if (attemptIncapacitated(a) || attemptSpecialAttack(a, t, force_melee) || attemptReload(a, force_melee) || attack_used == NULL) {
		// All exit points consolidated here, except the final one.
		// These four conditions, in order, determine the attacker is not capable of attacking using the standard attack()
		// It relies on lazy conditional OR, since each condition has side effects.
		return false;
	}

	// for tanks, attack_used->ranged returns false, so we need to check if it's a tank
	bool melee = !attack_used->ranged && !(!a.is_armed() && a.animalgloss && a.specialattack == ATTACK_CANNON);

	bool sneak_attack = a.is_armed() && (attack_used->can_backstab && a.align == ALIGN_LIBERAL && !mistake) && (t.cantbluff < 1 && !isThereASiteAlarm());

	if (sneak_attack)
	{
		if (sitealarmtimer > 10 || sitealarmtimer < 0) {
			sitealarmtimer = 10;
		}
		t.cantbluff = 2;
	}

	mvaddstrAlt(16, 1, firstStrike(a, t, mistake, sneak_attack, attack_used), gamelog);

	gamelog.newline();
	pressAnyKey();
	if (goodguyattack) set_color_easy(GREEN_ON_BLACK_BRIGHT);
	else set_color_easy(RED_ON_BLACK_BRIGHT);

	int bonus = 0; // Accuracy bonus or penalty that does NOT affect damage or counterattack chance
				   //SKILL EFFECTS
	const int wsk = attack_used->skill;

	// Basic roll
	int aroll = a.skill_roll(wsk);
	// In a car chase, the driver provides the defence roll instead of the victim.
	int droll;
	if (mode != GAMEMODE_CHASECAR)
	{
		droll = t.skill_roll(SKILL_DODGE) / 2;
	}
	else
	{
		droll = driverDodgeSkill(t);
		bonus += driverAttackBonus(a);
	}
	if (sneak_attack)
	{
		droll = t.attribute_roll(ATTRIBUTE_WISDOM) / 2;
		aroll += a.skill_roll(SKILL_STEALTH);
		a.train(wsk, 10);
	}
	else
	{
		trainDodgeDriveAndAttack(a, t, droll, aroll, wsk);
	}
	// Hostages interfere with attack
	if (t.prisoner != NULL) bonus -= LCSrandom(10);
	if (a.prisoner != NULL) aroll -= LCSrandom(10);
	//Injured people suck at attacking, are like fish in a barrel to attackers
	if (mode == GAMEMODE_CHASEFOOT)
	{
		// If in a foot chase, double the debilitating effect of injuries
		healthmodroll(aroll, a);
		healthmodroll(droll, t);
		healthmodroll(droll, t);
	}
	else if (mode == GAMEMODE_CHASECAR)
	{
		// In a car chase, the driver is applying dodge rolls even for crippled people.
		healthmodroll(aroll, a);
		driverHealthModRoll(droll, t);
	}
	else
	{
		// Any other case (site fight) normal penalties.
		healthmodroll(aroll, a);
		healthmodroll(droll, t);
	}
	AttackInfliction attackI(sneak_attack, aroll, droll, attack_used);
	// Weapon accuracy bonuses and penalties
	bonus += attack_used->accuracy_bonus;
	//USE BULLETS
	int bursthits = 0; // Tracks number of hits.
	int thrownweapons = 0; // Used by thrown weapons to remove the weapons at the end of the turn if needed
	if (!a.is_armed()) //Move into WEAPON_NONE -XML
	{
		// Martial arts multi-strikes
		bursthits = 1 + LCSrandom(a.get_skill(SKILL_HANDTOHAND) / 3 + 1);
		if (bursthits > 5) bursthits = 5;
		if (a.animalgloss) bursthits = 1; // Whoops, must be human to use martial arts fanciness
	}
	else
	{
		int num_attacks = attack_used->number_attacks;
		if (sneak_attack) {
			num_attacks = 1;
			bursthits = 1;
		}
		directlyUseWeapon(a, num_attacks, thrownweapons, bursthits, attack_used);
		if (!sneak_attack) {
			for (int i = 0; i < num_attacks; i++)
			{
				// Each shot in a burst is increasingly less likely to hit
				if (aroll + bonus - i * attack_used->successive_attacks_difficulty > droll)
					bursthits++;
			}
		}
	}
	//HIT!
	if (aroll + bonus > droll)
	{
		inflictDamage(bursthits, a, t, attackI);
	}
	else
	{
		set_color_easy(WHITE_ON_BLACK_BRIGHT);
		if (melee && aroll < droll - 10 && t.blood>70 && t.animalgloss == ANIMALGLOSS_NONE
			&& t.is_armed() && t.get_weapon().get_attack(false, true, true) != NULL)
		{
			string str2 = t.name;
			str2 += CONST_fight154;
			mvaddstrAlt(17, 1, str2, gamelog);
			gamelog.newline();
			pressAnyKey();
			goodguyattack = !goodguyattack;
			attack(t, a, 0, true);
			goodguyattack = !goodguyattack;
		}//TODO if missed person, but vehicle is large, it might damage the car. 
		else {
			string str2;
			if (sneak_attack)
			{
				str2 = t.name;
				str2 += singleSpace + pickrandom(cry_alarm);
				setSiteAlarmOne();
			}
			else {
				str2 += unsuccessfulHit(a, t, droll);

			}
			mvaddstrAlt(17, 1, str2, gamelog);

			gamelog.newline();
			printparty();
			if (mode == GAMEMODE_CHASECAR ||
				mode == GAMEMODE_CHASEFOOT) printchaseencounter();
			else printencounter();
			pressAnyKey();



		}
	}
	for (; thrownweapons > 0; thrownweapons--)
	{
		if (a.has_thrown_weapon)
			a.ready_another_throwing_weapon();
		a.drop_weapon(NULL);
	}
	// This is the only point in the function that returns true
	return true;
}
void singleSquadMemberAttack(const int p, const bool wasalarm) {
	//extern char foughtthisround;
	extern Deprecatedsquadst *activesquad;
	extern Deprecatednewsstoryst *sitestory;

	extern int sitecrime;
	//extern short cursite;
	extern DeprecatedCreature encounter[ENCMAX];
	vector<int> super_enemies;
	vector<int> dangerous_enemies;
	vector<int> enemies;
	vector<int> non_enemies;
	for (int e = 0; e < ENCMAX; e++)
	{
		if (encounter[e].alive&&encounter[e].exists)
		{
			if (encounter[e].enemy())
			{
				if (encounter[e].animalgloss == ANIMALGLOSS_TANK &&
					encounter[e].stunned == 0)
					super_enemies.push_back(e);
				else if ((encounter[e].is_armed() ||
					(encounter[e].type == CREATURE_COP && encounter[e].align == ALIGN_MODERATE) ||
					encounter[e].type == CREATURE_SCIENTIST_EMINENT ||
					encounter[e].type == CREATURE_JUDGE_LIBERAL ||
					encounter[e].type == CREATURE_JUDGE_CONSERVATIVE ||
					encounter[e].type == CREATURE_CORPORATE_CEO ||
					encounter[e].type == CREATURE_POLITICIAN ||
					encounter[e].type == CREATURE_RADIOPERSONALITY ||
					encounter[e].type == CREATURE_NEWSANCHOR ||
					encounter[e].type == CREATURE_MILITARYOFFICER ||
					encounter[e].specialattack != -1) &&
					encounter[e].blood >= 40 &&
					encounter[e].stunned == 0)
					dangerous_enemies.push_back(e);
				else enemies.push_back(e);
			}
			else non_enemies.push_back(e);
		}
	}
	if (!(len(super_enemies) + len(dangerous_enemies) + len(enemies))) return;
	int target;
	// If there are CONST_fight161, shoot at one of them unless we're using a persuasion-based attack
	if (len(super_enemies) &&
		((activesquad->squad[p]->type != CREATURE_SCIENTIST_EMINENT &&
			activesquad->squad[p]->type != CREATURE_JUDGE_LIBERAL &&
			activesquad->squad[p]->type != CREATURE_JUDGE_CONSERVATIVE &&
			activesquad->squad[p]->type != CREATURE_CORPORATE_CEO &&
			activesquad->squad[p]->type != CREATURE_POLITICIAN &&
			activesquad->squad[p]->type != CREATURE_RADIOPERSONALITY &&
			activesquad->squad[p]->type != CREATURE_NEWSANCHOR &&
			activesquad->squad[p]->type != CREATURE_MILITARYOFFICER &&
			!activesquad->squad[p]->get_weapon().get_specific_bool(BOOL_MUSICAL_ATTACK_)) ||
			(!activesquad->squad[p]->get_weapon().get_specific_bool(BOOL_MUSICAL_ATTACK_) &&
				activesquad->squad[p]->is_armed())))
		target = pickrandom(super_enemies);
	// Else, if there are CONST_fight162, shoot at one of them
	else if (len(dangerous_enemies))
		target = pickrandom(dangerous_enemies);
	// Else, if there are regular enemies, shoot at one of them
	else if (len(enemies)) target = pickrandom(enemies);
	// Else, we skipped a CONST_fight163 because it we're using a persuasion-based attack but it's the only enemy left so we have to pick it
	else target = pickrandom(super_enemies);
	char mistake = 0;
	// Mistaken attack
	/*
	Mistakenly attacking innocents: if skill is 8 or higher, there is no chance of mistakenly hitting innocents (except when used as a human shield).
	If skill is 7 or lower, the odds are based on skill, with a maximum of 10% chance at skill = 0;
	Melee weapons only require a skill of 4.
	If skill is 3 or lower, the odds are based on skill, with a maximum of 5% chance at skill = 0;
	*/
	if (len(non_enemies) && activesquad->squad[p]->get_weapon_skill() < (4 + (activesquad->squad[p]->get_weapon().is_ranged() * 4)) &&
		!LCSrandom(10 + 2 * (5 + 5 * activesquad->squad[p]->get_weapon().is_ranged()) * activesquad->squad[p]->get_weapon_skill()))
		// Mistaken attack
	{
		target = pickrandom(non_enemies);
		mistake = 1;
	}
	bool actual;
	const short beforeblood = encounter[target].blood;
	if (encounter[target].align == 1) mistake = 1;
	actual = attack(*activesquad->squad[p], encounter[target], mistake);
	if (actual)
	{
		if (mistake)
		{
			alienationcheck(mistake);
			sitestory->crime.push_back(CRIME_ATTACKED_MISTAKE);
			sitecrime += 10;
		}
		else
		{
			sitecrime += 3;
			addjuice(*(activesquad->squad[p]), 1, 200);
		}
		sitestory->crime.push_back(CRIME_ATTACKED);
		// Charge with assault if first strike
		if (isThereASiteAlarm() && (!wasalarm || (beforeblood > encounter[target].blood && beforeblood == 100)))
		{
			if (!activesquad->squad[p]->is_armed())
				criminalize(*activesquad->squad[p], LAWFLAG_ASSAULT);
			else criminalize(*activesquad->squad[p], LAWFLAG_ARMEDASSAULT);
		}
	}
	if (!encounter[target].alive)
	{
		delenc(target, 1);
		if (!mistake)
		{
			for (int p = 0; p < 6; p++)
			{
				if (activesquad->squad[p] == NULL) continue;
				if (!activesquad->squad[p]->alive) continue;
				addjuice(*(activesquad->squad[p]), 5, 500);
			}
		}
	}
}

void yourinitialattack() {
	extern Deprecatedsquadst *activesquad;
	const bool wasalarm = isThereASiteAlarm();
	for (int p = 0; p < 6; p++)
	{
		if (activesquad->squad[p] == NULL) continue;
		if (!activesquad->squad[p]->alive) continue;
		singleSquadMemberAttack(p, wasalarm);
	}
}

vector<NameAndAlignment> getEncounterNameAndAlignment();
/* attack handling for each side as a whole */
void youattack()
{
	extern char foughtthisround;
	extern Deprecatedsquadst *activesquad;
	extern Deprecatednewsstoryst *sitestory;
	extern int sitecrime;
	extern short cursite;
	vector<NameAndAlignment> encounter = getEncounterNameAndAlignment();
	extern vector<DeprecatedCreature *> pool;
	foughtthisround = 1;
	goodguyattack = true;
	yourinitialattack();
	for (int e = 0; e < ENCMAX; e++)
	{
		if (encounter[e].exists && encounter[e].alive && encounter[e].enemy)
		{
			setSiteAlarmOne();
			break;
		}
	}
	//COVER FIRE
	if (LocationsPool::getInstance().isThereASiegeHere(cursite))
	{
		for (int p = 0; p < CreaturePool::getInstance().lenpool(); p++)
		{
			if (!pool[p]->alive) continue;
			if (pool[p]->align != 1) continue;
			if (pool[p]->squadid != -1) continue;
			if (pool[p]->location != cursite) continue;
			// Juice check to engage in cover fire
			// 10% chance for every 10 juice, starting at
			// 10% chance for 0 juice -- caps out at 100%
			// chance to fire at 90 juice
			//if(LCSrandom(10)-pool[p]->juice/10>0)continue;
			if (pool[p]->get_weapon().get_attack(true, false, false))
			{
				char conf = 0;
				if (pool[p]->get_weapon().get_ammoamount() > 0) conf = 1;
				if (pool[p]->get_weapon().get_attack(true, false, false)->uses_ammo)
					if (pool[p]->can_reload()) conf = 1;
				if (conf)
				{
					vector<int> goodtarg, badtarg;
					for (int e = 0; e < ENCMAX; e++)
					{
						if (encounter[e].alive&&encounter[e].exists)
						{
							if (encounter[e].enemy)goodtarg.push_back(e);
							else badtarg.push_back(e);
						}
					}
					if (!len(goodtarg)) return;
					int target = pickrandom(goodtarg);
					char mistake = 0;
					// Mistaken attack
					/*
					Mistakenly attacking innocents: if skill is 8 or higher, there is no chance of mistakenly hitting innocents (except when used as a human shield).
					If skill is 7 or lower, the odds are based on skill, with a maximum of 10% chance at skill = 0;
					Melee weapons only require a skill of 4.
					If skill is 3 or lower, the odds are based on skill, with a maximum of 5% chance at skill = 0;
					*/
					if (len(badtarg) && pool[p]->get_weapon_skill() < (4 + (pool[p]->get_weapon().is_ranged() * 4)) &&
						!LCSrandom(10 + 2 * (5 + 5 * pool[p]->get_weapon().is_ranged()) * pool[p]->get_weapon_skill()))
					{
						target = pickrandom(badtarg);
						mistake = 1;
					}
					bool actual;
					actual = attackPoolEncounter(p, target, mistake);
					if (actual)
					{
						if (mistake)
						{
							alienationcheck(mistake);
							sitestory->crime.push_back(CRIME_ATTACKED_MISTAKE);
							sitecrime += 10;
						}
						if (!pool[p]->is_armed())
							criminalize(*pool[p], LAWFLAG_ASSAULT);
						else criminalize(*pool[p], LAWFLAG_ARMEDASSAULT);
					}
					if (!encounter[target].alive) delenc(target, 1);
				}
			}
		}
	}
}
enum LOOP_CONTINUATION {
	RETURN_ZERO,
	RETURN_ONE,
	REPEAT
};
void conservatise(const int e);
// RETURN_ONE - special meaning, additional conditionals
// RETURN_ZERO - break surrounding loop
LOOP_CONTINUATION singleEnemyAttack(const int e, const bool armed) {

	extern short mode;
	extern char foughtthisround;
	extern Log gamelog;
	extern Deprecatedsquadst *activesquad;

	extern int sitecrime;
	// Enemies don't attack
	extern bool NOENEMYATTACK;
	extern DeprecatedCreature encounter[ENCMAX];
	extern coordinatest loc_coord;
	extern siteblockst levelmap[MAPX][MAPY][MAPZ];

	if (!encounter[e].exists) return REPEAT;
	if (!encounter[e].alive) return REPEAT;
	if (isThereASiteAlarm() && encounter[e].type == CREATURE_BOUNCER && encounter[e].align != ALIGN_LIBERAL)
		conservatise(e);
	if (encounter[e].enemy()) encounter[e].cantbluff = 2;

	if (mode != GAMEMODE_CHASECAR)
	{
		// Encountered creature will flee if:
		// (a) Non-Conservative, and not recently converted via music or some other mechanism
		// (b) Conservative, no juice, unarmed, non-tank/animal, enemy is armed, and fails a morale check based in part on injury level
		// (c) Conservative, and lost more than 55% blood
		// (d) There's a fire, they are not firefighters, and they fail a random check
		// Encountered creatures will never flee if they are tanks, animals, or so hurt they can't move
		char fire = 0;
		if (mode == GAMEMODE_SITE)
		{
			if (levelmap[loc_coord.locx][loc_coord.locy][loc_coord.locz].flag & SITEBLOCK_FIRE_START ||
				levelmap[loc_coord.locx][loc_coord.locy][loc_coord.locz].flag & SITEBLOCK_FIRE_END)
				fire = 1;
			else if (levelmap[loc_coord.locx][loc_coord.locy][loc_coord.locz].flag & SITEBLOCK_FIRE_PEAK)
				fire = 2;
		}
		if (((!encounter[e].enemy() ||
			(encounter[e].juice == 0 && !encounter[e].is_armed() && armed&&encounter[e].blood<signed(70 + LCSrandom(61))))
			&& !(encounter[e].flag & CREATUREFLAG_CONVERTED)) || (encounter[e].blood < 45 && encounter[e].juice < 200)
			|| ((fire*LCSrandom(5) >= 3) && !(encounter[e].type == CREATURE_FIREFIGHTER)))
		{
			if (encounter[e].animalgloss == ANIMALGLOSS_NONE)
			{

				return RETURN_ONE;
			}
		}
	}

	vector<int> goodtarg, badtarg;
	if (encounter[e].enemy())
	{
		for (int p = 0; p < 6; p++) {
			if (activesquad->squad[p] != NULL) {
				if (activesquad->squad[p]->alive) { goodtarg.push_back(p); }
			}
		}
	}
	else
	{
		for (int e2 = 0; e2 < ENCMAX; e2++)
		{
			if (!encounter[e2].exists) continue;
			if (!encounter[e2].alive) continue;
			if (encounter[e2].align != -1) continue;
			goodtarg.push_back(e2);
		}
	}
	for (int e2 = 0; e2 < ENCMAX; e2++)
	{
		if (!encounter[e2].exists) continue;
		if (!encounter[e2].alive) continue;
		if (encounter[e2].enemy()) continue;
		badtarg.push_back(e2);
	}
	if (!len(goodtarg)) return RETURN_ZERO;
	int target = pickrandom(goodtarg);
	char canmistake = 1;
	int encnum = 0;
	for (int e2 = 0; e2 < ENCMAX; e2++) if (encounter[e2].exists) encnum++;
	if ((encounter[e].type == CREATURE_SCIENTIST_EMINENT ||
		encounter[e].type == CREATURE_JUDGE_LIBERAL ||
		encounter[e].type == CREATURE_JUDGE_CONSERVATIVE ||
		encounter[e].type == CREATURE_CORPORATE_CEO ||
		encounter[e].type == CREATURE_POLITICIAN ||
		encounter[e].type == CREATURE_RADIOPERSONALITY ||
		encounter[e].type == CREATURE_NEWSANCHOR ||
		encounter[e].type == CREATURE_MILITARYOFFICER) && encnum < ENCMAX) canmistake = 0;
	bool actual;
	if (canmistake)
	{
		if (encounter[e].enemy())
		{
			if (activesquad->squad[target]->prisoner != NULL && !LCSrandom(2))
			{
				// Mistaken attack
				actual = attack(encounter[e], *activesquad->squad[target]->prisoner, 1);
				if (!activesquad->squad[target]->prisoner->alive)
				{
					if (activesquad->squad[target]->prisoner->squadid == -1)
					{
						clearmessagearea();
						set_color_easy(WHITE_ON_BLACK_BRIGHT);
						mvaddstrAlt(16, 1, activesquad->squad[target]->name, gamelog);
						addstrAlt(CONST_fight164, gamelog);
						addstrAlt(activesquad->squad[target]->prisoner->name, gamelog);
						addstrAlt(CONST_fight165, gamelog);
						gamelog.newline();
						const int prisonerType = activesquad->squad[target]->prisoner->type;
						if (prisonerType == CREATURE_CORPORATE_CEO ||
							prisonerType == CREATURE_POLITICIAN ||
							prisonerType == CREATURE_RADIOPERSONALITY ||
							prisonerType == CREATURE_NEWSANCHOR ||
							prisonerType == CREATURE_SCIENTIST_EMINENT ||
							prisonerType == CREATURE_JUDGE_CONSERVATIVE ||
							prisonerType == CREATURE_MILITARYOFFICER) sitecrime += 30;
						makeloot(*activesquad->squad[target]->prisoner);
						pressAnyKey();
						delete_and_nullify(activesquad->squad[target]->prisoner);
					}
				}
				return REPEAT;
			}
		}
		// Mistaken attack
		/*
		Mistakenly attacking innocents: if skill is 8 or higher, there is no chance of mistakenly hitting innocents (except when used as a human shield).
		If skill is 7 or lower, the odds are based on skill, with a maximum of 20% chance at skill = 0;
		Melee weapons only require a skill of 4.
		If skill is 3 or lower, the odds are based on skill, with a maximum of 10% chance at skill = 0;
		*/
		if (len(badtarg) && encounter[e].get_weapon_skill() < (4 + (encounter[e].get_weapon().is_ranged() * 4)) &&
			!LCSrandom(10 + 2 * (5 + 5 * encounter[e].get_weapon().is_ranged()) * encounter[e].get_weapon_skill()))
		{
			target = pickrandom(badtarg);
			if (encounter[target].flag & CREATUREFLAG_CONVERTED)
				actual = attack(encounter[e], encounter[target], 0);
			// Mistaken Attack
			else actual = attack(encounter[e], encounter[target], 1);
			if (!encounter[target].alive) delenc(target, 1);
			return REPEAT;
		}
	}
	if (encounter[e].enemy())
		actual = attack(encounter[e], *activesquad->squad[target], 0);
	else actual = attack(encounter[e], encounter[target], 0);
	return REPEAT;
}
void enemyattack()
{
	extern Log gamelog;
	extern short mode;
	extern char foughtthisround;

	extern Deprecatedsquadst *activesquad;

	extern bool NOENEMYATTACK;
	extern DeprecatedCreature encounter[ENCMAX];

	foughtthisround = 1;
	goodguyattack = false;
	bool armed = false;
	for (int i = 0; i < 6; i++)
	{
		if (activesquad->squad[i] == NULL) break;
		if (activesquad->squad[i]->is_armed()) armed = true;
	}
	if (NOENEMYATTACK) {
		return;
	}
	char printed;
	for (int e = 0; e < ENCMAX; e++)
	{
		switch (singleEnemyAttack(e, armed)) {
		case RETURN_ONE:
			if (!incapacitated(encounter[e], 0, printed))
			{
				if (printed)
				{
					printparty();
					if (mode == GAMEMODE_CHASECAR ||
						mode == GAMEMODE_CHASEFOOT) printchaseencounter();
					else printencounter();
					pressAnyKey();
				}
				clearmessagearea();
				mvaddstrAlt(16, 1, encounter[e].name, gamelog);
				if ((encounter[e].wound[BODYPART_LEG_RIGHT] & WOUND_NASTYOFF) ||
					(encounter[e].wound[BODYPART_LEG_RIGHT] & WOUND_CLEANOFF) ||
					(encounter[e].wound[BODYPART_LEG_LEFT] & WOUND_NASTYOFF) ||
					(encounter[e].wound[BODYPART_LEG_LEFT] & WOUND_CLEANOFF) ||
					(encounter[e].blood < 45))
					addstrAlt(pickrandom(escape_crawling), gamelog);
				else addstrAlt(pickrandom(escape_running), gamelog);
				gamelog.newline();
				delenc(e, 0);
				e--;
				printparty();
				if (mode == GAMEMODE_CHASECAR ||
					mode == GAMEMODE_CHASEFOOT) printchaseencounter();
				else printencounter();
				pressAnyKey();
			}
			break;
		case RETURN_ZERO:
			return;
		}
	}
}
string damtypeToUpperSpineString(const char damtype) {
	string damageDescription;

	if (damtype & WOUND_SHOT) damageDescription += (CONST_fight166);
	else (damageDescription += CONST_fight167);

	return damageDescription;
}
string damtypeToLowerSpineString(const char damtype) {
	string damageDescription;

	if (damtype & WOUND_SHOT)damageDescription += CONST_fight168;
	else damageDescription += (CONST_fight169);

	return damageDescription;
}
string damtypeToRightLungString(const char damtype) {
	string damageDescription;

	if (damtype & WOUND_SHOT)damageDescription += (CONST_fight170);
	else if (damtype & WOUND_TORN)damageDescription += (CONST_fight171);
	else damageDescription += (CONST_fight172);

	return damageDescription;
}
string damtypeToLeftLungString(const char damtype) {
	string damageDescription;

	if (damtype & WOUND_SHOT)damageDescription += (CONST_fight173);
	else if (damtype & WOUND_TORN)damageDescription += (CONST_fight174);
	else damageDescription += (CONST_fight175);

	return damageDescription;
}
string damtypeToHeartString(const char damtype) {
	string damageDescription;

	if (damtype & WOUND_SHOT)damageDescription += (CONST_fight176);
	else if (damtype & WOUND_TORN)damageDescription += (CONST_fight177);
	else damageDescription += (CONST_fight178);

	return damageDescription;
}
string damtypeToLiverString(const char damtype) {
	string damageDescription;

	if (damtype & WOUND_SHOT)damageDescription += (CONST_fight179);
	else if (damtype & WOUND_TORN)damageDescription += (CONST_fight180);
	else damageDescription += (CONST_fight181);

	return damageDescription;
}
string damtypeToStomachString(const char damtype) {
	string damageDescription;

	if (damtype & WOUND_SHOT)damageDescription += (CONST_fight182);
	else if (damtype & WOUND_TORN)damageDescription += (CONST_fight183);
	else damageDescription += (CONST_fight184);

	return damageDescription;
}
string damtypeToRightKidneyString(const char damtype) {
	string damageDescription;

	if (damtype & WOUND_SHOT)damageDescription += (CONST_fight185);
	else if (damtype & WOUND_TORN)damageDescription += (CONST_fight186);
	else damageDescription += (CONST_fight187);

	return damageDescription;
}
string damtypeToLeftKidneyString(const char damtype) {
	string damageDescription;

	if (damtype & WOUND_SHOT)damageDescription += (CONST_fight188);
	else if (damtype & WOUND_TORN)damageDescription += (CONST_fight189);
	else damageDescription += (CONST_fight190);

	return damageDescription;
}
string damtypeTo9String(const char damtype) {
	string damageDescription;

	return damageDescription;
}
string damtypeToSpleenString(const char damtype) {
	string damageDescription;

	if (damtype & WOUND_SHOT)damageDescription += (CONST_fight191);
	else if (damtype & WOUND_TORN)damageDescription += (CONST_fight192);
	else damageDescription += (CONST_fight193);

	return damageDescription;
}
string damtypeToRibsString(const char damtype, const char ribminus, const int ribsleft, const string name) {
	string damageDescription;
	if (ribminus > 1)
	{
		if (ribminus == ribsleft)
			damageDescription += (CONST_fight207);
		damageDescription += (name);
		damageDescription += (CONST_fight208);
		damageDescription += (name);
		damageDescription += (CONST_fight196);
	}
	else if (ribsleft > 1)
	{
		damageDescription += (CONST_fight210);
		damageDescription += (name);
		damageDescription += (CONST_fight198);
	}
	else
	{
		damageDescription += (name);
		damageDescription += (CONST_fight199);
	}
	if (damtype & WOUND_SHOT)damageDescription += (CONST_fight200);
	else damageDescription += (CONST_fight201);
	return damageDescription;
}
//std::string bodypartName(Bodyparts w, AnimalGlosses t);
string specialWoundPossibilityBody(
	DeprecatedCreature &t,
	const char breakdam,
	const char pokedam,
	const char damtype)
{
	DeprecatedCreature* target = &t;
	string damageDescription = blankString;
	switch (LCSrandom(11))
	{
	case 0:
		if (target->special[SPECIALWOUND_UPPERSPINE] && breakdam)
		{
			damageDescription += (target->name);
			damageDescription += damtypeToUpperSpineString(damtype);
			target->special[SPECIALWOUND_UPPERSPINE] = 0;
			if (target->blood > 20) target->blood = 20;
		}
		break;
	case 1:
		if (target->special[SPECIALWOUND_LOWERSPINE] && breakdam)
		{
			damageDescription += (target->name);
			damageDescription += damtypeToLowerSpineString(damtype);
			target->special[SPECIALWOUND_LOWERSPINE] = 0;
			if (target->blood > 20) target->blood = 20;
		}
		break;
	case 2:
		if (target->special[SPECIALWOUND_RIGHTLUNG] && pokedam)
		{
			damageDescription += (target->name);
			damageDescription += damtypeToRightLungString(damtype);
			target->special[SPECIALWOUND_RIGHTLUNG] = 0;
			if (target->blood > 20) target->blood = 20;
		}
		break;
	case 3:
		if (target->special[SPECIALWOUND_LEFTLUNG] && pokedam)
		{
			damageDescription += (target->name);
			damageDescription += damtypeToLeftLungString(damtype);
			target->special[SPECIALWOUND_LEFTLUNG] = 0;
			if (target->blood > 20) target->blood = 20;
		}
		break;
	case 4:
		if (target->special[SPECIALWOUND_HEART] && pokedam)
		{
			damageDescription += (target->name);
			damageDescription += damtypeToHeartString(damtype);
			target->special[SPECIALWOUND_HEART] = 0;
			if (target->blood > 3) target->blood = 3;
		}
		break;
	case 5:
		if (target->special[SPECIALWOUND_LIVER] && pokedam)
		{
			damageDescription += (target->name);
			damageDescription += damtypeToLiverString(damtype);
			target->special[SPECIALWOUND_LIVER] = 0;
			if (target->blood > 50) target->blood = 50;
		}
		break;
	case 6:
		if (target->special[SPECIALWOUND_STOMACH] && pokedam)
		{
			damageDescription += (target->name);
			damageDescription += damtypeToStomachString(damtype);
			target->special[SPECIALWOUND_STOMACH] = 0;
			if (target->blood > 50) target->blood = 50;
		}
		break;
	case 7:
		if (target->special[SPECIALWOUND_RIGHTKIDNEY] && pokedam)
		{
			damageDescription += (target->name);
			damageDescription += damtypeToRightKidneyString(damtype);
			target->special[SPECIALWOUND_RIGHTKIDNEY] = 0;
			if (target->blood > 50) target->blood = 50;
		}
		break;
	case 8:
		if (target->special[SPECIALWOUND_LEFTKIDNEY] && pokedam)
		{
			damageDescription += (target->name);
			damageDescription += damtypeToLeftKidneyString(damtype);
			target->special[SPECIALWOUND_LEFTKIDNEY] = 0;
			if (target->blood > 50) target->blood = 50;
		}
		break;
	case 9:
		if (target->special[SPECIALWOUND_SPLEEN] && pokedam)
		{
			damageDescription += (target->name);
			damageDescription += damtypeToSpleenString(damtype);
			target->special[SPECIALWOUND_SPLEEN] = 0;
			if (target->blood > 50) target->blood = 50;
		}
		break;
	case 10:
		if (target->special[SPECIALWOUND_RIBS] > 0 && breakdam)
		{
			int ribminus = LCSrandom(RIBNUM) + 1;
			if (ribminus > target->special[SPECIALWOUND_RIBS]) ribminus = target->special[SPECIALWOUND_RIBS];

			damageDescription += damtypeToRibsString(damtype, ribminus, target->special[SPECIALWOUND_RIBS], target->name);

			target->special[SPECIALWOUND_RIBS] -= ribminus;
		}
		break;
	}
	return damageDescription;
}
string damtypeToTeethString(const char damtype, const int woundTeeth, const string name, const int teethminus) {
	string damageDescription;
	if (teethminus > 1)
	{
		if (teethminus == woundTeeth)
		{
			damageDescription += (CONST_fight207);
		}
		damageDescription += tostring(teethminus);
		damageDescription += CONST_fight208;
		damageDescription += name;
		damageDescription += CONST_fight209;
	}
	else if (woundTeeth > 1)
	{
		damageDescription += (CONST_fight210);
		damageDescription += (name);
		damageDescription += (CONST_fight211);
	}
	else
	{
		damageDescription += (name);
		damageDescription += (CONST_fight212);
	}
	if (damtype & WOUND_SHOT)damageDescription += (CONST_fight213);
	else if (damtype & WOUND_BURNED)damageDescription += (CONST_fight214);
	else if (damtype & WOUND_TORN)damageDescription += (CONST_fight215);
	else if (damtype & WOUND_CUT)damageDescription += (CONST_fight216);
	else damageDescription += (CONST_fight217);
	return damageDescription;
}
string damtypeToFaceString(const char damtype) {
	string damageDescription;
	if (damtype & WOUND_SHOT)damageDescription += (CONST_fight202);
	else if (damtype & WOUND_BURNED)damageDescription += (CONST_fight203);
	else if (damtype & WOUND_TORN)damageDescription += (CONST_fight204);
	else if (damtype & WOUND_CUT)damageDescription += (CONST_fight205);
	else damageDescription += (CONST_fight206);
	return damageDescription;
}
string damtypeToRightEyeString(const char damtype) {
	string damageDescription;
	if (damtype & WOUND_SHOT)damageDescription += (CONST_fight218);
	else if (damtype & WOUND_BURNED)damageDescription += (CONST_fight219);
	else if (damtype & WOUND_TORN)damageDescription += (CONST_fight220);
	else if (damtype & WOUND_CUT)damageDescription += (CONST_fight221);
	else damageDescription += (CONST_fight222);
	return damageDescription;
}
string damtypeToLeftEyeString(const char damtype) {
	string damageDescription;
	if (damtype & WOUND_SHOT)damageDescription += (CONST_fight223);
	else if (damtype & WOUND_BURNED)damageDescription += (CONST_fight224);
	else if (damtype & WOUND_TORN)damageDescription += (CONST_fight225);
	else if (damtype & WOUND_CUT)damageDescription += (CONST_fight226);
	else damageDescription += (CONST_fight227);
	return damageDescription;
}
string damtypeToTongueString(const char damtype) {
	string damageDescription;

	if (damtype & WOUND_SHOT)damageDescription += (CONST_fight228);
	else if (damtype & WOUND_BURNED)damageDescription += (CONST_fight229);
	else if (damtype & WOUND_TORN)damageDescription += (CONST_fight230);
	else if (damtype & WOUND_CUT)damageDescription += (CONST_fight231);
	else damageDescription += (CONST_fight232);

	return damageDescription;
}
string damtypeToNoseString(const char damtype) {
	string damageDescription;

	if (damtype & WOUND_SHOT)damageDescription += (CONST_fight233);
	else if (damtype & WOUND_BURNED)damageDescription += (CONST_fight234);
	else if (damtype & WOUND_TORN)damageDescription += (CONST_fight235);
	else if (damtype & WOUND_CUT)damageDescription += (CONST_fight236);
	else damageDescription += (CONST_fight237);

	return damageDescription;
}
string damtypeToNeckString(const char damtype) {
	string damageDescription;

	if (damtype & WOUND_SHOT)damageDescription += (CONST_fight238);
	else damageDescription += (CONST_fight239);

	return damageDescription;
}

string specialWoundPossibilityHead(
	DeprecatedCreature &t,
	const char breakdam,
	//char pokedam,
	const char heavydam,
	const char damtype
) {
	DeprecatedCreature* target = &t;
	string damageDescription = blankString;
	switch (LCSrandom(7))
	{
	case 0:
		if ((target->special[SPECIALWOUND_RIGHTEYE] ||
			target->special[SPECIALWOUND_LEFTEYE] ||
			target->special[SPECIALWOUND_NOSE]) && heavydam)
		{
			damageDescription += (target->name);
			damageDescription += damtypeToFaceString(damtype);
			target->special[SPECIALWOUND_RIGHTEYE] = 0;
			target->special[SPECIALWOUND_LEFTEYE] = 0;
			target->special[SPECIALWOUND_NOSE] = 0;
			if (target->blood > 20)target->blood = 20;
		}
		break;
	case 1:
		if (target->special[SPECIALWOUND_TEETH] > 0)
		{
			int teethminus = LCSrandom(TOOTHNUM) + 1;
			if (teethminus > target->special[SPECIALWOUND_TEETH])
				teethminus = target->special[SPECIALWOUND_TEETH];
			damageDescription += damtypeToTeethString(damtype, target->special[SPECIALWOUND_TEETH], target->name, teethminus);
			target->special[SPECIALWOUND_TEETH] -= teethminus;
		}
		break;
	case 2:
		if (target->special[SPECIALWOUND_RIGHTEYE] && heavydam)
		{
			damageDescription += (target->name);
			damageDescription += damtypeToRightEyeString(damtype);
			target->special[SPECIALWOUND_RIGHTEYE] = 0;
			if (target->blood > 50)target->blood = 50;
		}
		break;
	case 3:
		if (target->special[SPECIALWOUND_LEFTEYE] && heavydam)
		{
			damageDescription += (target->name);
			damageDescription += damtypeToLeftEyeString(damtype);
			target->special[SPECIALWOUND_LEFTEYE] = 0;
			if (target->blood > 50)target->blood = 50;
		}
		break;
	case 4:
		if (target->special[SPECIALWOUND_TONGUE] && heavydam)
		{
			damageDescription += (target->name);
			damageDescription += damtypeToTongueString(damtype);
			target->special[SPECIALWOUND_TONGUE] = 0;
			if (target->blood > 50)target->blood = 50;
		}
		break;
	case 5:
		if (target->special[SPECIALWOUND_NOSE] && heavydam)
		{
			damageDescription += (target->name);
			damageDescription += damtypeToNoseString(damtype);
			target->special[SPECIALWOUND_NOSE] = 0;
			if (target->blood > 50)target->blood = 50;
		}
		break;
	case 6:
		if (target->special[SPECIALWOUND_NECK] && breakdam)
		{
			damageDescription += (target->name);
			damageDescription += damtypeToNeckString(damtype);
			target->special[SPECIALWOUND_NECK] = 0;
			if (target->blood > 20)target->blood = 20;
		}
		break;
	}
	return damageDescription;
}
/* abandoned liberal is captured by conservatives */
void capturecreature(DeprecatedCreature &t)
{
	extern short sitetype;
	extern short cursite;
	t.activity.type = ACTIVITY_NONE;
	t.drop_weapons_and_clips(NULL);
	//t.strip(NULL);
	Armor clothes = Armor(getarmortype(tag_ARMOR_CLOTHES));
	t.give_armor(clothes, NULL);
	freehostage(t, 2); // situation 2 = no message; this may want to be changed to 0 or 1
	if (t.prisoner)
	{
		if (t.prisoner->squadid == -1)
			delete t.prisoner;
		t.prisoner = NULL; // Stop hauling people
	}
	if (t.flag & CREATUREFLAG_JUSTESCAPED)
	{
		t.location = cursite;
		if (sitetype == SITE_GOVERNMENT_PRISON ||
			sitetype == SITE_GOVERNMENT_COURTHOUSE)
		{
			Armor prisoner = Armor(getarmortype(tag_ARMOR_PRISONER));
			t.give_armor(prisoner, NULL);
		}
		if (sitetype == SITE_GOVERNMENT_PRISON)
		{
			// Clear criminal record?
			t.heat = 0;
			for (int i = 0; i < LAWFLAGNUM; i++)
				t.crimes_suspected[i] = 0;
		}
	}
	else
		t.location = find_site_index_in_same_city(SITE_GOVERNMENT_POLICESTATION, cursite);
	t.squadid = -1;
}
/* pushes people into the current squad (used in a siege) */
void autopromote(const int loc)
{
	extern Deprecatedsquadst *activesquad;
	extern vector<DeprecatedCreature *> pool;
	if (!activesquad) return;
	const int partysize = squadsize(activesquad), partyalive = squadalive(activesquad);
	int libnum = 0;
	if (partyalive == 6) return;
	for (int pl = 0; pl < CreaturePool::getInstance().lenpool(); pl++)
	{
		if (pool[pl]->location != loc) continue;
		if (pool[pl]->alive&&pool[pl]->align == 1) libnum++;
	}
	if (partysize == libnum) return;
	for (int p = 0; p < 6; p++)
	{
		if (activesquad->squad[p] == NULL || !activesquad->squad[p]->alive)
		{
			for (int pl = 0; pl < CreaturePool::getInstance().lenpool(); pl++)
			{
				if (pool[pl]->location != loc) continue;
				if (pool[pl]->alive&&pool[pl]->squadid == -1 &&
					pool[pl]->align == 1)
				{
					if (activesquad->squad[p] != NULL) activesquad->squad[p]->squadid = -1;
					activesquad->squad[p] = pool[pl];
					activesquad->squad[p]->squadid = activesquad->id;
					break;
				}
			}
		}
	}
}

